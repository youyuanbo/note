# 面试题——第一期

## 自增

## 单例

## 类初始化与实例初始化

1. 类初始化

    类初始化时，会执行 clinit()方法，并且一个类的初始化只会执行一次此方法。

    如果一个类存在父类，会先初始化父类。
    clinit方法的构成：

    + 静态变量显示赋值代码
    + 静态代码块

    在初始化时，静态变量显示赋值代码与静态代码块按顺序从上往下执行

2. 实例初始化

    实例初始化就是执行 init()方法

    在一个类中，可能会重载多个 init()方法，有多少个构造器，就有多少个 init()方法。

    init方法的组成：

    + 非静态实例变量显示赋值代码
    + 非静态代码块
    + 对应构造器代码

    init方法的执行顺序：

    + 非静态实例变量显示赋值代码和非静态代码块代码从上到下按顺序执行
    + 对应的构造器代码最后执行

    每次创建实例对象，调用对应的构造器，执行的就是对应的 init方法

    init 方法的首行时super() 或super(实参列表)，即对应的父类 init方法

3. 对象多态性

    1. 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码
    2. 非静态方法前面都有一个默认的对象this
    3. this在构造器或init方法中，表示的是当前正在创建的对象

4. 方法的重写

    以下方法不能被重写：

    1. 被final关键字修饰的方法
    2. 被static关键字修饰的方法
    3. 被private关键字修饰的方法

    满足一下要求的方法，可以被重写：

    1. 方法名相同
    2. 形参列表相同
    3. 返回值类型相同
    4. 抛出的异常列表相同
    5. 修饰符相同

5. 代码

    ```java
    public class Father {
        //非静态实例变量显示赋值代码
        private int i = test();
        //静态实例变量显示赋值代码
        private static int j = method();
        //静态代码块
        static {
            System.out.println("(1)");
        }
        //构造器
        Father() {
            System.out.println("(2)");
        }
        //非静态代码块
        {
            System.out.println("(3)");
        }
        //非晶态方法
        public int test() {
            System.out.println("(4)");
            return 1;
        }   
        //静态方法
        public static int method() {
            System.out.println("(5)");
            return 1;
        }
    }
    
    ```

    ```java
    //存在继承关系，在初始化Son之前，会先初始化Father
    public class Son extends Father {
        //非静态实例变量显式赋值
        private int i = test();
        //静态变量显式赋值
        private static int j = method();
        //静态代码块
        static {
            System.out.println("(6)");
        }
        //构造方法
        Son() {
            System.out.println("(7)");
        }
        //非静态代码块
        {
            System.out.println("(8)");
        }
        //非静态方法
        public int test() {
            System.out.println("(9)");
            return 1;
        }
        //静态方法
        public static int method() {
            System.out.println("(10)");
            return 1;
        }
    
        //main
        public static void main(String[] args) {
            Son son1 = new Son();
            System.out.println();
            Son son2 = new Son();
    
        }
    }
    ```



## 方法的参数传递机制

1. 形参是基本数据类型

    传递数据值

2. 实参是引用数据类型

    - 传递地址值
    - 特殊类型：String、包装类等对象具有不可变

3. 代码

    ```java
    public class Param {
        public static void main(String[] args) {
            //基本数据类型，传递数据值
            int i = 1;
            //引用传递，传递地址值，“hello”存放在常量池中
            String string = "hello";
            Integer num = 200;
            int[] arr = {1, 2, 3, 4, 5};
            MyData myData = new MyData();
    
            change(i, string, num, arr, myData);
    
            System.out.println("i = " + i);
            System.out.println("string = " + string);
            System.out.println("num = " + num);
            System.out.println("arr = " + Arrays.toString(arr));
            System.out.println("myData.a = " + myData.a);
    
        }
    
        public static void change(int j, String s, Integer n, int[] a, MyData myData) {
            //值传递，改变原本存放在堆中的值，i变为2
            j += 1;
            //引用传递，“hello”与“world”存放于常量池中，具有不可变性
            // 执行完指令后，s执行了新的常量“helloworld”，原string指向不变
            s += "world";
            //n存放于堆中，是包装类型，具有不可变性，执行完指令后，n指向了201，原num指向不变
            n += 1;
            //数组a存放于对中，执行完指令后，数组的第一个元素加1。
            a[0] += 1;
            //myData是类对象，此处是引用传递，执行完指令后，a的值加1
            myData.a += 1;
    
        }
    }
    
    class MyData {
        int a = 10;
    }
    ```

4. 总结

    1. 一般的基础数据类型传递，不会影响原来的值
    2. 引用传递会影响原来的值
    3. String类型、包装类型的传递不会影响原来的值

## 递归与迭代

## 成员变量与局部变量

区别：

1. 声明的位置

    1. 局部变量：方法体重，形参，代码块中
    2. 成员变量：
        + 类变量：有static修饰
        + 实例变量：没有static修饰

2. 修饰符

    1. 局部变量：final
    2. 成员变量：public、protected、private、final、static、volatile、transient

3. 值存储的位置

    1. 局部变量：栈
    2. 实例变量：堆
    3. 类变量：方法区

4. 作用域

    1. 局部变量：从声明处开始，到所属的右大括号结束
    2. 实例变量：在当前类中使用“this.”（有时this.可以省略），在其他类中使用“对象名.”访问
    3. 类变量：在当前类中使用“类名.”（有时类名. 可以省略），在其他类中使用对象名. 或者类名. 访问

5. 生命周期

    1. 局部变量：每一个线程，每一次调用执行都是新的生命周期
    2. 实例变量：随着对象的创建而初始化，随着对象的被回收而消亡，每一个对象的实例变量都是独立的，每一个线程的实例变量也是独立的
    3. 类变量：随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量是共享的

6. 代码

    ```java
    package com.atguigu.variable;
    
    public class Variable {
        static int s;
        int i;
        int j;
    
        {
            int i = 1;
            i++;
            j++;
            s++;
        }
    
        public void test(int j) {
            j++;
            i++;
            s++;
        }
    
        public static void main(String[] args) {
            Variable variable1 = new Variable();
            Variable variable2 = new Variable();
            variable1.test(10);
            variable1.test(20);
            variable2.test(30);
            System.out.println(variable1.i + ", " + variable1.j + ", " + variable1.s);
            System.out.println(variable2.i + ", " + variable2.j + ", " + variable2.s);
        }
    }
    
    ```

## SpringBean的作用域之间有什么区别

1. 在Spring中，可以在<bean>元素的scope属性里设置bean的作用域，以决定这个bean是单实例的还是多实例的

2. 默认情况下，Spring只为每个在IOC容器里声明的bean创建唯一一个实例，整个IOC容器范围内都共享该实例：所以后续的getBean() 调用和bean引用豆浆返回这个唯一的bean实例。该作用域被称为singleton，它是所有bean的默认作用域。

3. 作用域

    | 类别      | 说明                                                         |
    | --------- | ------------------------------------------------------------ |
    | singleton | 在SpringIOC容器中仅存在一个Bean实例，Bean以单实例的方式存在  |
    | prototype | 每次调用getBean()时都会返回一个新的实例                      |
    | request   | 每次HTTP请求都会创建一个新的Bean，不同的HTTP Session使用不同的Bean。该作用域仅适用与WebApplicationContext环境 |
    | session   | 同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。该作用域仅适用与WebApplicationContext环境 |

4. 当scope为singleton时，IOC容器创建时，就会创建bean实例

5. 当scope为prototype时，IOC容器创建时，不会创建bean实例。在每次调用getBean方法时，再实例化bean。并且每次创建会创建一个新的Bean

## Spring支持的常用数据库事务传播属性和事务隔离级别

事务的属性：

1. propagation：用来设置事务的传播行为

2. 事务的传播行为：一个方法运行在了一个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新的事务

    + Propagation.REQUIRED：默认值，使用原来的事务
    + Propagation.REQUIRES_NEW：将原来的事务挂起，开启一个新的事务

3. isolation：用来设置事务的隔离级别

    + Isolation.REPEATABLE_READ：可重复读，MySQL默认的隔离级别
    + Isolation.READ_COMMITTED：读已提交，Oracle默认的隔离级别，开发时通常使用的隔离级别

4. 七种传播行为

    | 传播属性      | 描述                                                         |
    | ------------- | ------------------------------------------------------------ |
    | REQUIRED      | 如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行 |
    | REQUIRES_NEW  | 当前的方法必须启动新事务，并在它自己的事务内运行，如果有事务正在运行，应该将它挂起 |
    | SUPPORTS      | 如果有事务在运行，当前的方法就在这个事务内运行，否则它可以不运行在事务中 |
    | NOT_SUPPORTED | 当前的方法不应该运行在事务中，如果有运行的事务，将它挂起     |
    | MANDATORY     | 当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常 |
    | NEVER         | 当前的方法不应该运行在事务中，如果有运行的事务，就抛出异常   |
    | NEDTED        | 如股票有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行。否则，就启动一个新的事务，并在它自己的事务内运行 |

    事务传播属性可以在@Transactional注解的propagation属性中定义

5. 数据库事务并发问题

    假设现在有两个事务：Transaction1和Transaction2并发执行

    1. 脏读
        1. Transaction1 修改了某条记录
        2. Transaction2 读取了Transaction1 修改后的记录
        3. Transaction1 回滚
        4. Transaction2 读取的值无效
    2. 不可重复读
        1. Transaction1 读取当前值
        2. Transaction2 更改记录
        3. Transaction1 再次读取
    3. 幻读
        1. Transaction1 读取表中的部分数据
        2. Transaction2 向表中新增数据
        3. Transaction1 再次读取，发现多了很多数据

6. 事务的隔离级别

    1. 读未提交：READ UNCOMMITTED
        + 允许Transaction1 读取Transaction2 未提交的数据
        + 不可避免任何问题
    2. 读已提交：READ COMMITTED
        + 要求Transaction1 只能读取Transaction2 提交后的数据
        + 可以避免脏读
    3. 可重复读：REPEATABLE READ
        + 确保Transaction1 可以多次从一个字段中读取到相同的值，即Transaction1 执行期间禁止其他事务对这个字段进行更新
        + 可以避免脏读与不可重复读
    4. 串行化：SERIALIAABLE
        + 确保Transaction1 可以多次从一个表中读取到相同的行，在Transaction1 执行期间，禁止其它事务对这个表进行增删改等操作。
        + 可以避免任何并发问题，但性能十分低。

7. 各个隔离级别解决并发问题的能力

    |                  | 脏读 | 不可重复读 | 幻读 |
    | :--------------- | ---- | ---------- | ---- |
    | READ UNCOMMITTED | 有   | 有         | 有   |
    | READ COMMITTED   | 无   | 有         | 有   |
    | REPETABLE READ   | 无   | 无         | 有   |
    | SERIALIZABLE     | 无   | 无         | 无   |

8. 各种数据库产品对事务隔离级别的支持程度

    |                  | Oracle    | MySQL     |
    | ---------------- | --------- | --------- |
    | READ UNCOMMITTED | ×         | √         |
    | READ COMMITTED   | √（默认） | √         |
    | REPETABLE READ   | ×         | √（默认） |
    | SERIALIZABLE     | √         | √         |

    

