# 面试题——第一期

## 自增

## 单例

## 类初始化与实例初始化

1. 类初始化

    类初始化时，会执行 clinit()方法，并且一个类的初始化只会执行一次此方法。

    如果一个类存在父类，会先初始化父类。
    clinit方法的构成：

    + 静态变量显示赋值代码
    + 静态代码块

    在初始化时，静态变量显示赋值代码与静态代码块按顺序从上往下执行

2. 实例初始化

    实例初始化就是执行 init()方法

    在一个类中，可能会重载多个 init()方法，有多少个构造器，就有多少个 init()方法。

    init方法的组成：

    + 非静态实例变量显示赋值代码
    + 非静态代码块
    + 对应构造器代码

    init方法的执行顺序：

    + 非静态实例变量显示赋值代码和非静态代码块代码从上到下按顺序执行
    + 对应的构造器代码最后执行

    每次创建实例对象，调用对应的构造器，执行的就是对应的 init方法

    init 方法的首行时super() 或super(实参列表)，即对应的父类 init方法

3. 对象多态性

    1. 子类如果重写了父类的方法，通过子类对象调用的一定是子类重写过的代码
    2. 非静态方法前面都有一个默认的对象this
    3. this在构造器或init方法中，表示的是当前正在创建的对象

4. 方法的重写

    以下方法不能被重写：

    1. 被final关键字修饰的方法
    2. 被static关键字修饰的方法
    3. 被private关键字修饰的方法

    满足一下要求的方法，可以被重写：

    1. 方法名相同
    2. 形参列表相同
    3. 返回值类型相同
    4. 抛出的异常列表相同
    5. 修饰符相同

5. 代码

    ```java
    public class Father {
        //非静态实例变量显示赋值代码
        private int i = test();
        //静态实例变量显示赋值代码
        private static int j = method();
        //静态代码块
        static {
            System.out.println("(1)");
        }
        //构造器
        Father() {
            System.out.println("(2)");
        }
        //非静态代码块
        {
            System.out.println("(3)");
        }
        //非晶态方法
        public int test() {
            System.out.println("(4)");
            return 1;
        }   
        //静态方法
        public static int method() {
            System.out.println("(5)");
            return 1;
        }
    }
    
    ```

    ```java
    //存在继承关系，在初始化Son之前，会先初始化Father
    public class Son extends Father {
        //非静态实例变量显式赋值
        private int i = test();
        //静态变量显式赋值
        private static int j = method();
        //静态代码块
        static {
            System.out.println("(6)");
        }
        //构造方法
        Son() {
            System.out.println("(7)");
        }
        //非静态代码块
        {
            System.out.println("(8)");
        }
        //非静态方法
        public int test() {
            System.out.println("(9)");
            return 1;
        }
        //静态方法
        public static int method() {
            System.out.println("(10)");
            return 1;
        }
    
        //main
        public static void main(String[] args) {
            Son son1 = new Son();
            System.out.println();
            Son son2 = new Son();
    
        }
    }
    ```



## 方法的参数传递机制

1. 形参是基本数据类型

    传递数据值

2. 实参是引用数据类型

    - 传递地址值
    - 特殊类型：String、包装类等对象具有不可变

3. 代码

    ```java
    public class Param {
        public static void main(String[] args) {
            //基本数据类型，传递数据值
            int i = 1;
            //引用传递，传递地址值，“hello”存放在常量池中
            String string = "hello";
            Integer num = 200;
            int[] arr = {1, 2, 3, 4, 5};
            MyData myData = new MyData();
    
            change(i, string, num, arr, myData);
    
            System.out.println("i = " + i);
            System.out.println("string = " + string);
            System.out.println("num = " + num);
            System.out.println("arr = " + Arrays.toString(arr));
            System.out.println("myData.a = " + myData.a);
    
        }
    
        public static void change(int j, String s, Integer n, int[] a, MyData myData) {
            //值传递，改变原本存放在堆中的值，i变为2
            j += 1;
            //引用传递，“hello”与“world”存放于常量池中，具有不可变性
            // 执行完指令后，s执行了新的常量“helloworld”，原string指向不变
            s += "world";
            //n存放于堆中，是包装类型，具有不可变性，执行完指令后，n指向了201，原num指向不变
            n += 1;
            //数组a存放于对中，执行完指令后，数组的第一个元素加1。
            a[0] += 1;
            //myData是类对象，此处是引用传递，执行完指令后，a的值加1
            myData.a += 1;
    
        }
    }
    
    class MyData {
        int a = 10;
    }
    ```

4. 总结

    1. 一般的基础数据类型传递，不会影响原来的值
    2. 引用传递会影响原来的值
    3. String类型、包装类型的传递不会影响原来的值

## 递归与迭代

## 成员变量与局部变量

区别：

1. 声明的位置

    1. 局部变量：方法体重，形参，代码块中
    2. 成员变量：
        + 类变量：有static修饰
        + 实例变量：没有static修饰

2. 修饰符

    1. 局部变量：final
    2. 成员变量：public、protected、private、final、static、volatile、transient

3. 值存储的位置

    1. 局部变量：栈
    2. 实例变量：堆
    3. 类变量：方法区

4. 作用域

    1. 局部变量：从声明处开始，到所属的右大括号结束
    2. 实例变量：在当前类中使用“this.”（有时this.可以省略），在其他类中使用“对象名.”访问
    3. 类变量：在当前类中使用“类名.”（有时类名. 可以省略），在其他类中使用对象名. 或者类名. 访问

5. 生命周期

    1. 局部变量：每一个线程，每一次调用执行都是新的生命周期
    2. 实例变量：随着对象的创建而初始化，随着对象的被回收而消亡，每一个对象的实例变量都是独立的，每一个线程的实例变量也是独立的
    3. 类变量：随着类的初始化而初始化，随着类的卸载而消亡，该类的所有对象的类变量是共享的

6. 代码

    ```java
    package com.atguigu.variable;
    
    public class Variable {
        static int s;
        int i;
        int j;
    
        {
            int i = 1;
            i++;
            j++;
            s++;
        }
    
        public void test(int j) {
            j++;
            i++;
            s++;
        }
    
        public static void main(String[] args) {
            Variable variable1 = new Variable();
            Variable variable2 = new Variable();
            variable1.test(10);
            variable1.test(20);
            variable2.test(30);
            System.out.println(variable1.i + ", " + variable1.j + ", " + variable1.s);
            System.out.println(variable2.i + ", " + variable2.j + ", " + variable2.s);
        }
    }
    
    ```

## SpringBean的作用域之间有什么区别

1. 在Spring中，可以在<bean>元素的scope属性里设置bean的作用域，以决定这个bean是单实例的还是多实例的

2. 默认情况下，Spring只为每个在IOC容器里声明的bean创建唯一一个实例，整个IOC容器范围内都共享该实例：所以后续的getBean() 调用和bean引用豆浆返回这个唯一的bean实例。该作用域被称为singleton，它是所有bean的默认作用域。

3. 作用域

    | 类别      | 说明                                                         |
    | --------- | ------------------------------------------------------------ |
    | singleton | 在SpringIOC容器中仅存在一个Bean实例，Bean以单实例的方式存在  |
    | prototype | 每次调用getBean()时都会返回一个新的实例                      |
    | request   | 每次HTTP请求都会创建一个新的Bean，不同的HTTP Session使用不同的Bean。该作用域仅适用与WebApplicationContext环境 |
    | session   | 同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean。该作用域仅适用与WebApplicationContext环境 |

4. 当scope为singleton时，IOC容器创建时，就会创建bean实例

5. 当scope为prototype时，IOC容器创建时，不会创建bean实例。在每次调用getBean方法时，再实例化bean。并且每次创建会创建一个新的Bean

## Spring支持的常用数据库事务传播属性和事务隔离级别

事务的属性：

1. propagation：用来设置事务的传播行为

2. 事务的传播行为：一个方法运行在了一个开启了事务的方法中时，当前方法是使用原来的事务还是开启一个新的事务

    + Propagation.REQUIRED：默认值，使用原来的事务
    + Propagation.REQUIRES_NEW：将原来的事务挂起，开启一个新的事务

3. isolation：用来设置事务的隔离级别

    + Isolation.REPEATABLE_READ：可重复读，MySQL默认的隔离级别
    + Isolation.READ_COMMITTED：读已提交，Oracle默认的隔离级别，开发时通常使用的隔离级别

4. 七种传播行为

    | 传播属性      | 描述                                                         |
    | ------------- | ------------------------------------------------------------ |
    | REQUIRED      | 如果有事务在运行，当前的方法就在这个事务内运行，否则，就启动一个新的事务，并在自己的事务内运行 |
    | REQUIRES_NEW  | 当前的方法必须启动新事务，并在它自己的事务内运行，如果有事务正在运行，应该将它挂起 |
    | SUPPORTS      | 如果有事务在运行，当前的方法就在这个事务内运行，否则它可以不运行在事务中 |
    | NOT_SUPPORTED | 当前的方法不应该运行在事务中，如果有运行的事务，将它挂起     |
    | MANDATORY     | 当前的方法必须运行在事务内部，如果没有正在运行的事务，就抛出异常 |
    | NEVER         | 当前的方法不应该运行在事务中，如果有运行的事务，就抛出异常   |
    | NEDTED        | 如股票有事务在运行，当前的方法就应该在这个事务的嵌套事务内运行。否则，就启动一个新的事务，并在它自己的事务内运行 |

    事务传播属性可以在@Transactional注解的propagation属性中定义

5. 数据库事务并发问题

    假设现在有两个事务：Transaction1和Transaction2并发执行

    1. 脏读
        1. Transaction1 修改了某条记录
        2. Transaction2 读取了Transaction1 修改后的记录
        3. Transaction1 回滚
        4. Transaction2 读取的值无效
    2. 不可重复读
        1. Transaction1 读取当前值
        2. Transaction2 更改记录
        3. Transaction1 再次读取
    3. 幻读
        1. Transaction1 读取表中的部分数据
        2. Transaction2 向表中新增数据
        3. Transaction1 再次读取，发现多了很多数据

6. 事务的隔离级别

    1. 读未提交：READ UNCOMMITTED
        + 允许Transaction1 读取Transaction2 未提交的数据
        + 不可避免任何问题
    2. 读已提交：READ COMMITTED
        + 要求Transaction1 只能读取Transaction2 提交后的数据
        + 可以避免脏读
    3. 可重复读：REPEATABLE READ
        + 确保Transaction1 可以多次从一个字段中读取到相同的值，即Transaction1 执行期间禁止其他事务对这个字段进行更新
        + 可以避免脏读与不可重复读
    4. 串行化：SERIALIAABLE
        + 确保Transaction1 可以多次从一个表中读取到相同的行，在Transaction1 执行期间，禁止其它事务对这个表进行增删改等操作。
        + 可以避免任何并发问题，但性能十分低。

7. 各个隔离级别解决并发问题的能力

    |                  | 脏读 | 不可重复读 | 幻读 |
    | :--------------- | ---- | ---------- | ---- |
    | READ UNCOMMITTED | 有   | 有         | 有   |
    | READ COMMITTED   | 无   | 有         | 有   |
    | REPETABLE READ   | 无   | 无         | 有   |
    | SERIALIZABLE     | 无   | 无         | 无   |

8. 各种数据库产品对事务隔离级别的支持程度

    |                  | Oracle    | MySQL     |
    | ---------------- | --------- | --------- |
    | READ UNCOMMITTED | ×         | √         |
    | READ COMMITTED   | √（默认） | √         |
    | REPETABLE READ   | ×         | √（默认） |
    | SERIALIZABLE     | √         | √         |


## SpringMVC的工作流程

SpringMVC处理模型数据的方式：

1. 将方法的返回值设置为ModelAndView

2. 在方法的入参中传入Map、Model或ModelMap

3. 流程

    ![1568943511573](assets\1568943511573.png)

4. 、

## MyBatis中下划线转驼峰

1. 在编写SQL语句时，给字段取别名

    ```sql
    select last_name lastName from user;
    ```

    

2. 在MyBatis配置文件中，配置下划线转驼峰

    ```xml
    <settings>
    	<setting name="mapUnderscopeToCamelCase" value="true"></setting>
    </settings>
    ```

    

3. 在Mapper映射文件中，使用resultMap来自定义映射

    ```xml
<!--自定义映射-->
    <resultMap type="User" id="myMap">
    <!--映射主键-->
    	<id column="id" property="id"/>
        <!--映射last_name-->
        <id column="last_name" property="lastName"/>
    </resultMap>
    <!--查询-->
    <select id="getUserById" resultMap="myMap">
    	select last_name from User where id = #{id}
    </select>
    ```
    
4. 、

## Linux常用服务类相关命令

1. 常用基本命令——进程类（centos 6）

    1. 注册在系统中的标准化程序
    2. 有方便统一的管理方式（常用的方法）
        + service 服务名 start
        + service 服务名 stop
        + service 服务名 restart
        + service 服务名 reload
        + service 服务名 status
    3. 查看服务的方法 /etc/init.d/服务名
    4. 通过chkconfig命令设置开机自启
        + 查看服务 chkconfig --list | grep 服务名
        + chkconfig --level 5 服务名 on
    5. 关闭某服务开启自启
        + chkconfig –level 5 服务名 off

2. 运行级别 runlevel （centos6）

    开机——BIOS——/boot——init进程——运行几倍——运行级对应的服务

    1. 查看默认级别 cat /etc/inittab
    2. linux系统有7中运行级别（runlevel）：常用的级别是3 和 5
        + 0：系统停机状态，系统默认运行级别不能设置为0，否则不能正常启动
        + 1：单用户工作状态，root权限，用于维护系统，禁止远程登录
        + 2：多用户状态（没有NFS），不支持网络
        + 3：完全的多用户状态（有NFS），登录后进入控制台命令行模式
        + 4：系统未使用，保留
        + 5：X11控制台，登录后进入图形GUI模式
        + 6：系统正常关闭并重启，默认运行级别不能设置为6，否则不能正常启动

3. 基本常用命令——进程类（Centos7）

    1. 注册在系统中的标准化程序
    2. 有方便统一的管理方式（常用的方法）
        + systemctl start 服务名（XXX.service）
        + systemctl restart 服务名（XXX.service）
        + systemctl stop 服务名（XXX.service）
        + systemctl reload 服务名（XXX.service）
        + systemctl status 服务名（XXX.service）
    3. 查看服务的方法 /usr/lib/systemd/system
    4. 查看服务的命令
        + systemctl list-unit-files
        + systemctl --type service
    5. 通过systemctl 命令设置自启动
        + 自启动：systemctl enable service_name
        + 不自启动：systemctl disable service_name

## git分支相关命令

1. 创建分支

    + git branch branch_name

2. 查看分支

    + git branch -v 

3. 切换分支

    + git chechout branch_name

4. 创建并切换分支

    + git checkout -b branch_name

5. 合并分支

    + 先切换到主分支（master），合并dev（即将dev合并到master上）
    + git checkout master
    + git merge branch_name

6. 删除分支

    + 先切换到主干分支（master）git checkout master
    + git branch -D branch_name

7. git工作流

    ![1568947270889](assets\1568947270889.png)

8. 

## Redis持久化

​	redis提供了2个不同形式的持久化方式

1. RDB（Redis DataBase）

    + 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是进行Snapshot快照，它恢复时是将快照文件直接读到内存中。

    + Redis会单独创建一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，在用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，RDB方式比AOF方式更加高效。

    + RDB的缺点是最后一次持久化的数据可能丢失。

    ![1568947770591](assets\1568947770591.png)

    

2. AOF（Appeend Of File）

    + 以日志的形式来记录每个操作，将Redis执行过的所有指令记录下来（读操作不记录），只许追加文件但不可以改写文件，Redis启动支出会读取文件重新构建数据。换言之，Redis重启的话就会根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作。

    + 优缺点

        ![1568948166392](assets\1568948166392.png)

        

## MySQL什么时候适合建索引

1. 索引

    索引是帮助MySql高效获取数据的**数据结构**

2. 优缺点：

    1. 优点：提高数据的检索效率（降低IO），降低数据排序成本（降低	CPU）
    2. 缺点：降低更新表的速度，因为更新表时，不仅要保存数据，还要保存索引，以及调整索引

3. 需要创建索引

    1. 主键自动建立唯一索引
    2. 频繁作为查询条件的关键字应该创建索引
    3. 查询中与其他表关联的字段，外键关系建立索引
    4. 单键/组合做银的选择问题，组合索引性价比更高
    5. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
    6. 查询中统计或者分组字段

4. 不需要创建索引

    1. 表记录太少
    2. 经常增删改的表或者字段
    3. Where条件里用不到的字段
    4. 过滤性不好的字段不适合创建索引


## JVM垃圾回收机制

1. JVM垃圾回收机制

2. GC发生在JVM哪部分

    GC发生在JVM的堆里

3. 有哪几种GC

4. GC算法

    1. 引用计数法

        ![1568949117445](assets\1568949117445.png)

    2. 复制算法

        在年轻代中使用此算法

        ![1568949234165](assets\1568949234165.png)

    3. 标记清除

        老年代一般是由标记清除或者是标记清除与标记整理的混合实现

        ![1568949360941](assets\1568949360941.png)

    4. 标记压缩

        老年代

        ![1568949481822](assets\1568949481822.png)

        在整理压缩阶段，不再对标记的对象做回收，而是通过所有存活对象都向一端移动，然后直接清除边界以外的内存。

        

    5. 标记清除压缩

## Redis在项目中的使用场景

1.  、

    | 数据类型 | 使用场景                                                     |
    | -------- | ------------------------------------------------------------ |
    | String   | 比如封锁一个IP地址（以便共享），使用Incrty命令               |
    | Hash     | 存储用户信息  Hset(key, field, value) Hset(userKey, id, 101) |
    | List     | 实现最新消息的排行，还可以利用LIst的push命令，将任务存在list集合中，也可以使用pop将任务从集合中取出。使用Redis——list来模拟消息队列（电商中的秒杀就可以采用这种方式来完成） |
    | Set      | set可以自动去重。（微博中将每个人的集合存储在集合中（set），同一个好友不能添加两次，求两个人的共同微博好友，求交集就可以了） |
    | ZSet     | （SortedSet）以某一个条件为权重，进行排序。在电商中，查看商品，可以综合排名，也可以按照价格排名 |

## Elasticsearch与Solr的区别

1.  背景：它们都是以Lucene搜索服务器为基础，开发的一款优秀的、==高性能==的企业级搜索服务器。

    1.  高性能：它们的查询方式是——基于分词技术构建的==倒排索引==

2.  开发语言：都是使用java开发的

3.  诞生时间

    1.  Solr：2004年
    2.  ES：2010年，更新，功能更强大

4.  区别

    1.  当实时建立索引时，Solr会产生IO阻塞，而ES不会。所以ES的查询性能要高于solr
    2.  在不断动态添加数据的时候，solr的检索效率会下降，而ES没有什么变化
    3.  Solr是利用Zookeeper进行分布式管理，而ES自身带有分布式系统管理功能；Solr一般需要部署到Web服务器（Tomcat）上才能使用，而启动tomcat时需要配置Solr与tomcat的关联。（==Solr的本质是一个动态web项目==）
    4.  Solr支持更多的格式数据（xml，json，csv），而ES仅支持json文件格式
    5.  Solr是传统搜索应用的有力解决方案，但是ES更适用于新兴的实时搜索应用
        1.  单纯的对已有的数据进行检索，solr效率更高
        2.  动态添加数据或实时搜索，ES效率更高
    6.  Solr官网提供的功能更多；而ES本身更注重核心功能，一些高级功能需要使用第三方插件

5.  Solr集群图

    ![1568993787515](assets\1568993787515.png)

    ![1568993859455](assets\1568993859455.png)

6.  ES集群图

    ![1568993888339](assets\1568993888339.png)

## 单点登录

1.  概念：一处登录，多处使用

2.  一般在分布式系统中使用

3.  、

    ![1569030129039](assets\1569030129039.png)

    ![1569030209439](assets\1569030209439.png)

## 购物车实现

1.  购物车与用户的关系
    1.  一个用户对应一个购物车
    2.  单点登录的实现一定在购物车之前
2.  与购物车有关的操作有哪些
    1.  添加购物车
        1.  用户未登录状态
            1.  用户未登录，应该将数据保存在哪里？（Redis或者Cookie）
            2.  如果浏览器禁用了Cookie，是不能进行单点登录，也就不能存储在Cookie
            3.  如果存储在Redis，可以为用户生成一个UUID，标识用户
        2.  用户已登录
            1.  存在Redis缓存中，为了读写速度快，因为购物车会频繁地进行增删改查。数据存储在Redis中，使用Hash来存储
                1.  Hash：hset(key, field, value)
                    +   key: ==user:userId:cart==
            2.  存在数据库，以便长久保存，反之Redis出现故障
    2.  展示购物车
        1.  未登录
            1.  直接从Cookie中取出数据，展示
        2.  已登录
            1.  用户一旦登录，必须显示数据库（或Redis），并且加上Cookie中的购物车数据

## 消息队列在项目中的使用

1.  背景

    在分布式系统中如何处理高并发？由于在高并发环境下，来不及同步处理用户的请求，会导致请求阻塞。（比如，统一时间，大量的insert、update之类的请求同时到达数据库，此时会同时出现行锁与表锁，甚至会导致请求堆积很多，从而触发too many connections错误）对于此问题，使用消息队列可以解决（异步通信）。

2.  异步

    ![1569031956341](assets\1569031956341.png)

3.  并行

    ![1569032103015](assets\1569032103015.png)

4.  排队

    ![1569032124503](assets\1569032124503.png)

5.  消息队列在电商中的使用场景

    ![1569032283871](assets\1569032283871.png)

6.  消息队列的弊端：消息的不确定性

    1.  采用延迟队列、轮询技术即可解决

7.  在java中推荐使用activeMQ