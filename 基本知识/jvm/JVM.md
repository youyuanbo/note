# JVM

## JVM组成

![1560687696355](image\1560687696355.PNG)

JVM是运行在操作系统上的，它与硬件没有直接的交互。

![1560688241227](image\1560688241227.png)

1. Class Loader类加载器
2. Execution Engine执行引擎负责负责解释命令，提交操作系统执行
3. Native Interface 本地接口
4. ==Runtime data area 运行数据区==

多线程的状态：

1. New
2. Runnable
3. Blocked
4. Waiting、Timed_Waiting
5. Terminated

JNI: Java Native Interface



![1560689598513](image\1560689598513.png)



![1560689874097](image\1560689874097.png)

## 栈管运行、堆管存储

## 栈

![1560690924369](image\1560690924369.png)

![1560691447582](image\1560691447582.png)

![1560691615367](image\1560691615367.png)

异常：

java.lang.StackOverflowError

![1560692223028](image\1560692223028.png)

三种JVM

Sun公司的HotSpot

BEA公司的JRockit

IBM的J9 VM

堆

![1560742071392](image\1560742071392.png)

新生区

![1560750197936](image\1560750197936.png)

![1560751336864](E:\Note\jvm\image\1560751336864.png)

![1560752215332](image\1560752215332.png)

![1560752264858](image\1560752264858.png)

![1560753030503](image\1560753030503.png)

![1560754037241](image\1560754037241.png)

![1560754265684](image\1560754265684.png)

![1560754378091](image\1560754378091.png)

![1560755225657](image\1560755225657.png)

![1560755297243](image\1560755297243.png)

GC算法总体概述

![1560755514896](image\1560755514896.png)

JVM在进行垃圾回收时，并非每次都对上面三个内存区域一起回收，大部分时候回收的都是指新生代。因此，GC按照回收的区域又分为两种类型，一种是普通GC（Minor GC），一种是全局GC（Major GC or Full GC）

1. 普通GC：只针对新生代区域的GC
2. 全局GC：针对老年代的GC，偶尔伴随对新生代以及对永久代的GC

Minor GC会把Eden中所有活的对象都移动到Survivor中，如果Survivor中区中存放不下，那么剩下的活的对象将被移动到老年区中。即一旦收集后，Eden就变成空的了。

当对象在Eden区出生后，在经过一次GC后，如果还活着。如果to区有足够的空间来存放在存放Eden区与from区的存活对象，则使用==复制算法==将Eden和from区的对象复制到to区，然后清空Eden与From区。复制完成后，交换from区与to区。清空后，将剩余的对象年龄设置为1，以后没进行一次Minor GC，存活下来的对象，年龄加1，当年龄大于达到某个值（默认为15）时，这些对象就会移动到老年代。

通过-XX：MaxTuenringThresHold 设置对象在新生代中存活的次数

在进行GC时，谁空谁是To

Eden：From：To = 1:1:1

年轻代中的GC，主要是复制算法（Copying）

HotSpot JVM把年轻代分为了三个部分：1个Eden区和2个Survivor区（分别叫From和To）。默认比例为8:1:1，一把情况下，新创建的对象都会把被分配的Eden区（一些大队向特殊处理），这些对象经过第一次Minor GC后，如果仍然存活，将会被移动到Survivor区。对象在Survivor区中没熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到老年代中。因为年轻代中的对戏那个基本都是朝生夕死（80%以上），所以在==年轻代的垃圾回收算法使用的是复制算法==，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就精还活着的对象复制到另一块上面。==复制算法不会产生内存碎片==。

在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区的“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍然存活的对象会根据他们的年龄值来决定去向。年龄达到一定值（年龄阈值，可以通过-XX：MaxTenuringThreshold来设置）的对象会被移动到老年代中，没有达到阈值的对象会被复制到“To”区域。==经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次G吃前的“To”。==不管怎样，都会保证“To”区为空。Minor会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。

复制算法弥补了标记/清除算法中，内存布局混乱的缺点。不过与此同时，它的缺点也相当明显。

1. 它浪费了10%的内存
2. 如果对象的存活率很高，复制所花费的时间，将变得不可忽视。所以，如果使用复制算法，==对象的存活率应当是非常低才行。==

 

==老年代一般是由标记清除或者是标记清除与标记整理的混合实现==

标记清除（Mark-Sweep）

![1560760816147](image\1560760816147.png)

标记整理（Mark-Compact）

![1560761086553](image\1560761086553.png)

标记/整理算法唯一的缺点就是效率不高，不仅要标记所有存活的对象，还要整理所有存活对象的引用地址。从效率上来说，标记/整理算法要低于复制算法。

![1560761510147](image\1560761510147.png)

![1560761569019](image\1560761569019.png)



























