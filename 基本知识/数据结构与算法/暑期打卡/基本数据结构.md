# 基本数据结构

题目列表

1. LeetCode 1 Two Sum
2. LeetCode 187 Repeated DNA Sequences
3. LeetCode 706 Design HashMap
4. LeetCode 652 Find Duplicate Subtrees
5. LeetCode 560 Subarray Sum Equals K
6. LeetCode 547 Friend Circles 
7. LeetCode 684 Redundant Connection
8. LeetCode 692 Top K Frequent Words 
9. LeetCode 295 Find Median from Data Stream
10. LeetCode 352 Data Stream as Disjoint Intervals



## 题解

### LeetCode 1 Two Sum

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] result = new int[2];
        Map<Integer, Integer> map = new HashMap<>();
        int numsLength = nums.length;
        for (int i = 0; i < numsLength; i++) {
            int temp = target - nums[i];
            if (map.containsKey(temp)) {
                result[0] = map.get(temp);
                result[1] = i;
                return result;
            }
            map.put(nums[i], i);
        }
        return result;
    }
}
```

### LeetCode 187 Repeated DNA Sequences

```java
class Solution {
    public ArrayList<String> findRepeatedDnaSequences(String s) {
        //存储所有的子串
        Set<String> temp = new HashSet<>();
        //存储重复的子串
        Set<String> result = new HashSet<>();
        //遍历字符串s
        for (int i = 0; i + 10 <= s.length(); i++) {
            //截取字符串
            String string = s.substring(i, i + 10);
            //如果temp中已经包含了该子串，说明该子串重复
            if (temp.contains(string)) {
                //将该子串添加到result中
                result.add(string);
            } else {
                //如果temp中没有包含该子串，将该子串添加到temp中
                temp.add(string);
            }
        }
        //返回result
        return new ArrayList<>(result);
    }
}
```





```java
class Solution {
    public ArrayList<String> findRepeatedDnaSequences(String s) {
        Map<String, Integer> map = new HashMap<>();
        Set<String> result = new HashSet<>();
        for (int i = 0; i + 10 <= s.length(); i++) {
            String substring = s.substring(i, i + 10);
            if (map.containsKey(substring)) {
                result.add(substring);
            } else {
                map.put(substring, 1);
            }
        }
        return new ArrayList<>(result);
    }
}
```





### LeetCode 706 Design HashMap

```java
public class MyHashMap {

    int size = 20011;

    LinkedList<Pair>[] hashMap;

    /**
     * Initialize your data structure here.
     */
    public MyHashMap() {
        this.hashMap = new LinkedList[size];
    }

    public Pair find(int key) {
        int hashcode = hashcode(key);
        if (isEmpty(hashcode)) {
            return null;
        } else {
            for (Pair pair : hashMap[hashcode]) {
                if (pair.getKey() == key) {
                    return pair;
                }
            }
        }
        return null;
    }

    /**
     * value will always be non-negative.
     */
    public void put(int key, int value) {

        int hashcode = hashcode(key);
        if (isEmpty(hashcode)) {
            hashMap[hashcode] = new LinkedList<>();
            hashMap[hashcode].add(new Pair(key, value));
        } else {
            Pair pair = find(key);
            if (pair == null) {
                hashMap[hashcode].add(new Pair(key, value));
            } else {
                pair.setValue(value);
            }
        }
    }

    /**
     * Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key
     */
    public int get(int key) {
        int hashcode = hashcode(key);

        if (isEmpty(hashcode)) {
            return -1;
        } else {
            Pair pair = find(key);
            if (pair == null) {
                return -1;
            } else {
                return pair.getValue();
            }
        }
    }

    /**
     * Removes the mapping of the specified value key if this map contains a mapping for the key
     */
    public void remove(int key) {
        int hashcode = hashcode(key);
        if (!isEmpty(hashcode)) {
            Pair pair = find(key);
            if (pair != null) {
                hashMap[hashcode].remove(pair);
            }
        }
    }

    public int hashcode(int key) {
        return key % size;
    }

    public boolean isEmpty(int hashcode) {

        return hashMap[hashcode] == null;
    }


    class Pair {
        int key;
        int value;

        Pair(int key, int value) {
            this.key = key;
            this.value = value;
        }

        public int getKey() {
            return key;
        }

        public int getValue() {
            return value;
        }

        public void setValue(int value) {
            this.value = value;
        }
    }


    public static void main(String[] args) {
        MyHashMap hashMap = new MyHashMap();
        hashMap.put(1, 1);
        hashMap.put(2, 2);
        System.out.println("hashMap.get(1) = " + hashMap.get(1));
        System.out.println("hashMap.get(3) = " + hashMap.get(3));
        hashMap.put(2, 1);
        System.out.println("hashMap.get(2) = " + hashMap.get(2));
        hashMap.remove(2);
        System.out.println("hashMap.get(2) = " + hashMap.get(2));

    }
}
```





### LeetCode 652 Find Duplicate Subtrees

```java
class Solution {
    //利用hash表来存储每棵树的谦虚遍历字符串
    Map<String, Integer> hash = new HashMap<>();
    //利用集合来存储结果集
    List<TreeNode> result = new ArrayList<>();

    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {

        dfs(root);

        return result;
    }

    public String dfs(TreeNode node) {
        //如果遇到节点为空，返回“#”
        if (node == null) {
            return "#";
        }

        //定义一个字符串来存储以当前节点为根的树的前序遍历
        StringBuilder cur = new StringBuilder();

        cur.append(node.val)
                //在值之间添加“，”，以示区别
                .append(",")
                //递归当前节点的左子树
                .append(dfs(node.left))
                .append(",")
                //递归当前节点的右子树
                .append(dfs(node.right));
        //获取当前字符串在hash中存储的次数
        Integer count = hash.getOrDefault(cur.toString(), 0);
        //将当前字符串存入hash表中（将value+1）
        hash.put(cur.toString(), count + 1);
        //如果当前字符串对应的value等于2，说明已经重复了
        if (hash.getOrDefault(cur.toString(), 0) == 2) {
            //将当前节点存入result中
            result.add(node);
        }
        //人会当前节点的前序遍历
        return cur.toString();
    }
}
```





### LeetCode 560 Subarray Sum Equals K

暴力




```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        if (nums.length == 0) {
            return 0;
        }
        int[] prefixSum = new int[nums.length + 1];
        prefixSum[0] = 0;
        for (int i = 1; i <= nums.length; i++) {
            prefixSum[i] = prefixSum[i - 1] + nums[i - 1];
        }

        int count = 0;

        for (int i = 0; i < prefixSum.length; i++) {
            for (int j = i + 1; j < prefixSum.length; j++) {
                if (prefixSum[j] - prefixSum[i] == k) {
                    count++;
                }
            }
        }

        return count;

    }
}
```


hash

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        Map<Integer, Integer> prefixSum = new HashMap<>();

        //将（0,1）作为第一个元素存入map中
        prefixSum.put(0, 1);
        //result是返回结果
        int result = 0;
        //遍历原数组
        for (int i = 0, sum = 0; i < nums.length; i++) {
            //计算前缀和
            sum += nums[i];
            //叠加，从前缀和中查看有多少计算结果是sum-k的
            result += prefixSum.getOrDefault(sum - k, 0);
            //将当前前缀和加入到map中
            prefixSum.put(sum, prefixSum.getOrDefault(sum, 0) + 1);
        }
        //返回计算结果
        return result;
    }
}
```





### LeetCode 547 Friend Circles 

### LeetCode 684 Redundant Connection

### LeetCode 692 Top K Frequent Words 

### LeetCode 295 Find Median from Data Stream

### LeetCode 352 Data Stream as Disjoint Intervals