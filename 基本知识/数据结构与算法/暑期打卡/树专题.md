# LeetCode暑期打卡——树专题

## 题目

1. LeetCode 98 Validate Binary Search Tree
2. LeetCode 101 Symmetric Tree  
3. LeetCode 94  Binary Tree Inorder Traversal   
4. LeetCode 105 Construct Binary Tree from Preorder and Inorder Traversal   
5. LeetCode 102 Binary Tree Level Order Traversal    
6. LeetCode 236 Lowest Common Ancestor of a Binary Tree    
7. LeetCode 297 Serialize and Deserialize Binary Tree  
8. LeetCode 543 Diameter of Binary Tree    
9. LeetCode 124 Binary Tree Maximum Path Sum      
10. LeetCode 173 Binary Search Tree Iterator   

## 题解

### 1. LeetCode 96 Validate Binary Search Tree

思路：

1. 初始化上界为Long.MIN_VALUE，下界为Long.MAX_VALUE
2. 如果当前节点为空，直接返回true
   1. 包括根节点为空，返回true
   2. 非根节点为空（到达了叶子节点）为空，返回true
3. 对每一个节点的值进行区间判断，如果值大于上界或小于下界，返回false
4. 递归左子树与右子树
   1. 左子树区间变化为：下界（minv），上界（root.val - 1）
   2. 右子树区间变化为：下界（root.val + 1），上界（maxv）

```java
class Solution {
	public boolean isValidBST(TreeNode root) {

		return dfs(root, Long.MIN_VALUE, Long.MAX_VALUE);
	}

	private boolean dfs(TreeNode root, long minv, long maxv) {
		if (root == null) {
			return true;
		}

		if (root.val < minv || root.val > maxv) {
			return false;
		}

		return dfs(root.left, minv, root.val - 1L)
				&& dfs(root.right, root.val + 1L, maxv);
	}
}
```



### 2. LeetCode 101 Symmetric Tree  

```java
/**
 * 使用递归完成镜像检测
 */
class Solution {
	public boolean isSymmetric(TreeNode root) {

		if (root == null) {
			return true;
		}

		return dfs(root.left, root.right);
	}

	private boolean dfs(TreeNode leftNode, TreeNode rightNode) {

		if (leftNode == null || rightNode == null) {
			return (leftNode == null) && (rightNode == null);
		}

		return (leftNode.val == rightNode.val)
				&& dfs(leftNode.right, rightNode.left)
				&& dfs(leftNode.left, rightNode.right);
	}
}
```

```java
/**
 * 迭代式判断二叉树镜像，借助队列完成
 */
class Solution {
	public boolean isSymmetric(TreeNode root) {

		Queue<TreeNode> treeNodeQueue = new LinkedList<>();

		treeNodeQueue.add(root);
		treeNodeQueue.add(root);

		while (!treeNodeQueue.isEmpty()) {
			TreeNode p = treeNodeQueue.poll();
			TreeNode q = treeNodeQueue.poll();

			if (p == null && q == null) {
				continue;
			}


			if (p == null || q == null) {
				return false;
			}

			if (p.val != q.val) {
				return false;
			}

			treeNodeQueue.add(p.left);
			treeNodeQueue.add(q.right);
			treeNodeQueue.add(p.right);
			treeNodeQueue.add(q.left);
		}

		return true;
	}

}
```

```java
/**
 * 迭代式判断二叉树镜像，借助栈完成
 */
class Solution {
	public boolean isSymmetric(TreeNode root) {

		if (root == null) {
			return true;
		}

		Stack<TreeNode> left = new Stack<>();
		Stack<TreeNode> right = new Stack<>();

		TreeNode leftRoot = root.left;
		TreeNode rightRoot = root.right;

		while (leftRoot != null || rightRoot != null || !left.isEmpty() || !right.isEmpty()) {
			while (leftRoot != null && rightRoot != null) {
				left.push(leftRoot);
				leftRoot = leftRoot.left;

				right.push(rightRoot);
				rightRoot = rightRoot.right;
			}

			if (leftRoot != null || rightRoot != null) {
				return false;
			}

			leftRoot = left.pop();
			rightRoot = right.pop();

			if (leftRoot.val != rightRoot.val) {
				return false;
			}

			leftRoot = leftRoot.right;
			rightRoot = rightRoot.left;
		}

		return true;
	}
}
```



### 3. LeetCode 94  Binary Tree Inorder Traversal   

思路：

1. 申请一个变量resultList，作为返回结果集
2. 如果根节点为空，返回空的resultList
3. 申请一个栈，用于存储节点
4. 循环
   1. 将树的最左边一条链上的所有元素加入到栈中
   2. 取出栈顶元素，并将节点的值加入到结果集中
   3. 遍历当前节点的右子树
5. 返回结果集

```java
/**
 * 使用非递归完成中序遍历
 */
class Solution {
	public List<Integer> inorderTraversal(TreeNode root) {
		List<Integer> resultList = new LinkedList<>();
		if (root == null) {
			return resultList;
		}
		Stack<TreeNode> stack = new Stack<>();
		TreeNode currentNode = root;
		while (currentNode != null || !stack.isEmpty()) {
			while (currentNode != null) {
				stack.push(currentNode);
				currentNode = currentNode.left;
			}
			currentNode = stack.pop();
			resultList.add(currentNode.val);
			currentNode = currentNode.right;
		}
		return resultList;
	}
}

/**
 * 使用递归完成二叉树的中序遍历
 */
class Solution {
	//定义一个集合，存储中序遍历的结果
	private List<Integer> resultList = new LinkedList<>();
	public List<Integer> inorderTraversal(TreeNode root) {
		if (root == null) {
			return resultList;
		}
		helper(root);
		return resultList;
	}
	private void helper(TreeNode root) {
		if (root.left != null) {
			helper(root.left);
		}
		resultList.add(root.val);

		if (root.right != null) {
			helper(root.right);
		}
	}
}
```

### 4. LeetCode 105 Construct Binary Tree from Preorder and Inorder Traversal 

```java
class Solution {

	Map<Integer, Integer> map = new HashMap<>();

	public TreeNode buildTree(int[] preorder, int[] inorder) {
		int n = preorder.length;

		//利用map来存储元素在中序遍历中的位置
		for (int i = 0; i < n; i++) {
			map.put(inorder[i], i);
		}

		return dfs(preorder, inorder, 0, n - 1, 0, n - 1);

	}

	/**
	 * 递归创建二叉树
	 * @param preOrder 谦虚遍历的数组
	 * @param inOrder 中序遍历的数组
	 * @param pl 前序遍历开始点（在数组中的下标）
	 * @param pr 前序遍历结束点
	 * @param il 中序遍历开始点
	 * @param ir 中序遍历结束点
	 * @return 返回头结点
	 */
	private TreeNode dfs(int[] preOrder, int[] inOrder, int pl, int pr, int il, int ir) {
		//如果pl大于pr，返回null
		if (pl > pr) return null;

		//从前序遍历中取出当前元素
		int val = preOrder[pl];
		//在map中取出当前元素在中序遍历中的位置
		int k = map.get(val);
		//计算子树的长度
		int len = k - il;
		//创建新结点
		TreeNode root = new TreeNode(val);
		//递归创建左子树
		root.left = dfs(preOrder, inOrder, pl + 1, pl + len, il, k - 1);
		//递归创建右子树
		root.right = dfs(preOrder, inOrder, pl + len + 1, pr, k + 1, ir);

		return root;
	}
}
```

### 5. LeetCode 102 Binary Tree Level Order Traversal    

```java
class Solution {
	//定义返回结果集
	private List<List<Integer>> resultList = new LinkedList<>();
	public List<List<Integer>> levelOrder(TreeNode root) {
		//如果root为空，返回空的结果集，这里不能直接返回null
		if (root == null) return resultList;
		//定义一个辅助队列
		Queue<TreeNode> queue = new LinkedList<>();
		//将root添加到队列中
		queue.add(root);
		//只要队列不为空，可以循环继续
		while (!queue.isEmpty()) {
			//定义子结果集
			List<Integer> list = new LinkedList<>();
			//获取队列长度
			int len = queue.size();
			//用队列现有长度来控制循环（在循环中，队列长度不变）
			for (int i = 0; i < len; i++) {
				//将队头元素出队
				TreeNode treeNode = queue.remove();
				//将队头元素的值添加到子结果集合中
				list.add(treeNode.val);
				//如果当前节点的左子节点存在，将其入队
				if (treeNode.left != null) {
					queue.add(treeNode.left);
				}
				//如果当前节点的右子节点存在，将其入队
				if (treeNode.right != null) {
					queue.add(treeNode.right);
				}
			}
			//将子结果集添加到结果结果集合中
			resultList.add(list);
		}
		//返回结果集
		return resultList;
	}
}
```

### 6.LeetCode 236 Lowest Common Ancestor of a Binary Tree

思路：

1. 如果以root为根的子树中包含p或q，则返回它们的最近公共祖先
2. 如果只包含p，则返回p；如果只包含q，则返回q；如果都不包含，则返回null
3. 如果左子树不包含p，也不包含q。此时右边有几种情况：
   1. 右子树也不包含p和q，right=null
   2. 右子树包含p或q，则right=p或right=q
   3. 右子树同时包含p和q，则right是最近公共祖先，返回right
4. 如果右子树同时不包含p和q。此时左子树有几种情况：
   1. 左子树也不包含p和q，left=null
   2. 左子树包含p或q，则left=p或left=q
   3. 左子树同时包含p和q，则left是最近公共祖先，返回left
5. 如果左右子树都不为空（左子树包含p，右子树包含q；或者左子树包含q，右子树包含p），则root就是最近公共祖先，返回root

```java
class Solution {
	public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
		//如果当前root节点为空，或者root等于p，或者root等于q，返回root
		if (root == null || root == p || root == q) return root;
		//递归左子树
		TreeNode left = lowestCommonAncestor(root.left, p, q);
		//递归右子树
		TreeNode right = lowestCommonAncestor(root.right, p, q);
		//如果左子树不包含p，也不包含q，则返回right
		if (left == null) return right;
		//如果右子树不包含p，也不包含q，则返回left
		if (right == null) return left;
		//如果root的左子树与右子树，都不包含p或q，返回root
		return root;
	}
}
```



### 7.LeetCode 297 Serialize and Deserialize Binary Tree  

思路：

1. 序列化：对二叉树进行前序遍历，对叶子节点的为空的子节点，用“#”代替，各个数字或“#”之间用“,”分隔
2. 反序列化：对序列化后的字符串，按照“,”分隔，得到一个字符串数组，一次遍历，递归创建二叉树

```java

import java.util.Arrays;

public class Codec {
	private StringBuilder result = new StringBuilder("");
	private static int index = 0;

	// Encodes a tree to a single string.
	public String serialize(TreeNode root) {
		if (root == null) {
			return "";
		}
		dfs1(root, result);

		return result.toString();
	}

	private void dfs1(TreeNode curr, StringBuilder result) {
		if (curr == null) {
			result.append("#,");
			return;
		}

		result.append(curr.val).append(",");

		dfs1(curr.left, result);
		dfs1(curr.right, result);
	}

	// Decodes your encoded data to tree.
	public TreeNode deserialize(String data) {
		if ("".equals(data) || data == null) {
			return null;
		}

		String[] temp = data.split(",");

		return dfs2(temp);
	}

	private TreeNode dfs2(String[] data) {
		if (data[index].equals("#")) {
			index++;
			return null;
		}

		TreeNode treeNode = new TreeNode(Integer.parseInt(data[index++]));
		treeNode.left = dfs2(data);
		treeNode.right = dfs2(data);
		return treeNode;
	}

	public static void main(String[] args) {

		TreeNode treeNode1 = new TreeNode(1);
		TreeNode treeNode2 = new TreeNode(2);
		TreeNode treeNode3 = new TreeNode(3);
		TreeNode treeNode4 = new TreeNode(4);
		TreeNode treeNode5 = new TreeNode(5);

		// treeNode1.left = treeNode2;
		// treeNode1.right = treeNode3;
		//
		// treeNode2.left = treeNode4;
		// treeNode2.right = treeNode5;

		String serialize = new Codec().serialize(treeNode1);
		System.out.println(serialize);

		TreeNode deserialize = new Codec().deserialize(serialize);
		System.out.println(deserialize.val);
	}
}
```



### 8.LeetCode 543 Diameter of Binary Tree    

```java
class Solution {
	private int result = 0;
	public int diameterOfBinaryTree(TreeNode root) {
		dfs(root);
		return result;
	}
	private int dfs(TreeNode root) {
		//如果当前节点为空，则该节点的深度为0
		if (root == null) return 0;
		//递归计算当前节点的左子树深度
		int left = dfs(root.left);
		//递归计算当前节点的右子树深度
		int right = dfs(root.right);
		//result是以当前节点为顶点的路径最大值，最大值等于左子树与右子树最大值之和
		result = Math.max(result, left + right);
		//返回：以当前节点为顶点，左子树与右子树中，深度的最大值
		return Math.max(left + 1, right + 1);
	}

}
```



### 9.LeetCode 124 Binary Tree Maximum Path Sum 

```java
class Solution {
	//定义全局变量，返回结果变量
	private int result = Integer.MIN_VALUE;
	public int maxPathSum(TreeNode root) {
		dfs(root);
		return result;
	}
    
	private int dfs(TreeNode currentNode) {
		//如果当前节点为空，返回0
		if (currentNode == null) {
			return 0;
		}

		//递归，计算当前节点左子树的最大节点值
		int leftValue = dfs(currentNode.left);
		//递归，计算当前节点右子树的最大节点值
		int rightValue = dfs(currentNode.right);
		//更新结果值，将原result值与（当前节点值 + 当前节点的左子树最大节点值 + 当前节点的右子树最大节点值）比较
		result = Math.max(result, leftValue + currentNode.val + rightValue);
		//返回：以当前节点为顶点，其值加上子树（左子树或右子树）最大节点值；如果节点值小于0，返回0
		return Math.max(0, currentNode.val + Math.max(leftValue, rightValue));
	}
}
```



### 10.LeetCode 173 Binary Search Tree Iterator