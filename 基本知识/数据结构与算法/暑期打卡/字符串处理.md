# 字符串处理

## 题目

1. 38 Count and Say 
2. 49 Group Anagrams 
3. 151 Reverse Words in a String   
4. 165 Compare Version Numbers    
5. 929 Unique Email Addresses
6. 5 Longest Palindromic Substring 
7. 6ZigZag Conversion
8. 3 Longest Substring Without Repeating Characters
9. 200 Number of Islands
10. 273 Integer to English Words  

## 题解

### 1.Leetcode 38 Count and Say 

```java
class Solution {
	public String countAndSay(int n) {

		//result是最后的返回结果
		StringBuffer result = new StringBuffer("1");
		//因为n大于等于1，所以不用考虑n等于1
		//i用于控制循环次数
		for (int i = 0; i < n - 1; i++) {
			//临时变量，用于存储中间计算结果
			StringBuffer temp = new StringBuffer();
			//循环，对当前字符串进行计算
			for (int j = 0; j < result.length(); j++) {
				//k用于计算当前字符的重复次数（个数）
				int k = j;
				//循环，统计当前字符出现的次数
				while (k < result.length() && result.charAt(k) == result.charAt(j)) {
					k++;
				}

				//将计算结果追加到临时变量中
				temp.append(k - j);
				temp.append(result.charAt(j));
				//j回退
				j = k - 1;
			}
			//将中间计算结果，赋值给最终结果
			result = temp;
		}
		//返回最终结果
		return result.toString();
	}
}
```



### 2.Leetcode  49 Group Anagrams 

思路：

1. 判断字符串是否为空，如果为空，返回一个空集合

2. 对传入的字符串数组进行遍历：

   1. 申请一个map，用于存储所有的排序后的字符串，以及此字符串的字母异位词
   2. 将每一个字符串转换为字符数组
   3. 对字符数组进行排序
   4. 将排序后的字符数组转换为字符串
   5. 如果map中没有把当前排序后的字符串作为key保存，则将当前排序后的字符串作为key保存在map中，并申请一个list作为对应的value
   6. 将之前遍历的未排序的字符串添加到对应的map中

3. 返回一个集合，集合中的元素是map中的所有value，而每一个value是一个集合

   使用排序 + 哈希完成：

```java
class Solution {
	public List<List<String>> groupAnagrams(String[] strs) {
		//判断字符串是否为空，如果为空，返回一个空的集合
		if (strs.length == 0) {
			return new ArrayList<>();
		}

		//使用map来存储每一种字符串，以及此种字符串对应的字母异位词
		Map<String, List<String>> ans = new HashMap<>();
		//遍历字符串数组
		for (String str : strs) {
			//将每一个字符串转换为字符数组
			char[] chars = str.toCharArray();
			//对字符数组进行排序
			Arrays.sort(chars);
			//将排序后的字符数组转换为字符串
			String key = String.valueOf(chars);
			//如果map中没有保存当前的排序过的字符串，就将当前字符串作为key存储在map中
			if (!ans.containsKey(key)) {
				ans.put(key, new ArrayList<>());
			}
			//将之前遍历到的字符串装填到对应的map中
			ans.get(key).add(str);
		}
		//将map中的所有value值取出，放在一个集合中，并返回
		return new ArrayList<>(ans.values());
	}
}
```

使用记数法 + 哈希来分组：

```java
class Solution {
	public List<List<String>> groupAnagrams(String[] strs) {

		if (strs.length == 0) {
			return new ArrayList<>();
		}

		Map<String, List<String>> map = new HashMap<>();
		//定义一个数组，来记录每个字符串中字母出现的次数
		int[] count = new int[26];
		for (String str : strs) {
			//将数组初始化为全0
			Arrays.fill(count, 0);
			//遍历字符串中的每一个字符，记录出现的次数
			for (char c : str.toCharArray()) {
				count[c - 'a']++;
			}

			//格式化：将count数组转换为字符串，作为map中的key
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < 26; i++) {
				stringBuilder.append("#").append(count[i]);
			}
			String key = stringBuilder.toString();
			
			if (!map.containsKey(key)) {
				map.put(key, new ArrayList<>());
			}
			//将原字符串放入map中
			map.get(key).add(str);
		}
		
		return new ArrayList<>(map.values());
	}
}
```



### 3.Leetcode  151 Reverse Words in a String   

```java
class Solution {
	public String reverseWords(String s) {

		//将字符串按照空格拆分，转为字符串数组
		String[] data = s.split(" ");

		//去掉数组中的空字符串，并将剩余的字符串拼在一起
		StringBuilder temp = new StringBuilder();
		for (String datum : data) {
			String trim = datum.trim();
			if (!"".equals(trim)) {
				//将数组中的每一个元素（一个字符串）取出，去空格，反转，追加到temp中，并追加空格
				temp.append(new StringBuilder(trim).reverse()).append(" ");
			}
		}
		//对整个temp字符串反转，去空格，返回
		return temp.reverse().toString().trim();
	}
}
```

```java
class Solution {
	public String reverseWords(String s) {

		//将字符串按照空格拆分，转为字符串数组
		String[] data = s.split(" ");

		//去掉数组中的空字符串，并将剩余的字符串拼在一起
		StringBuilder temp = new StringBuilder();
		for (String datum : data) {
			if (!"".equals(datum.trim())) {
				temp.append(datum.trim()).append(" ");
			}
		}

		//将新生成的字符串拆分为字符数组
		data = temp.toString().split(" ");
		//计算字符串数组的长度
		int length = data.length;

		StringBuilder result = new StringBuilder();
		//反转字符数组，并将反转后的字符数组拼接成字符串
		for (int i = length - 1; i >= 0; i--) {
			result.append(data[i]);
			result.append(" ");
		}
		//去掉最后的空格
		return result.substring(0, result.lastIndexOf(" "));
	}
}
```



### 4.Leetcode  165 Compare Version Numbers    

```java
class Solution {
	public int compareVersion(String version1, String version2) {
		// System.out.println("version1 = " + version1);
		// System.out.println("version2 = " + version2);

		//拆分字符串
		String[] version1Array = version1.split("\\.");
		String[] version2Array = version2.split("\\.");

		// System.out.println("version1Array = " + Arrays.toString(version1Array));
		// System.out.println("version2Array = " + Arrays.toString(version2Array));

		//计算两个数组中的最大长度
		int length = Math.max(version1Array.length, version2Array.length);
		//将字符串转为list
		List<String> version1List = new ArrayList<>(Arrays.asList(version1Array));
		List<String> version2List = new ArrayList<>(Arrays.asList(version2Array));

		//如果数组长度小于另一个数组长度，在集合中补0
		if (version1Array.length < length) {
			for (int i = version1Array.length; i < length; i++) {
				version1List.add("0");
			}
		}

		//如果数组长度小于另一个数组长度，在集合中补0
		if (version2Array.length < length) {
			for (int i = version2Array.length; i < length; i++) {
				version2List.add("0");
			}
		}

		// System.out.println("version1List = " + version1List);
		// System.out.println("version2List = " + version2List);
		
		//一次比较集合中的元素
		for (int i = 0; i < length; i++) {
			int temp1 = Integer.parseInt(version1List.get(i));
			int temp2 = Integer.parseInt(version2List.get(i));
			if (temp1 > temp2) {
				return 1;
			} else if (temp1 < temp2) {
				return -1;
			}
		}

		return 0;
	}
}
```

```java
class Solution {
	public int compareVersion(String version1, String version2) {
		//i,j用于控制循环
		int i = 0;
		int j = 0;
		while (i < version1.length() || j < version2.length()) {
			int x = i;
			int y = j;
			//x，y用于取出一个或一段数字
			while (x < version1.length() && version1.charAt(x) != '.') x++;
			while (y < version2.length() && version2.charAt(y) != '.') y++;
			//a，b用于存储待比较的数字
			int a = x == i ? 0 : Integer.parseInt(version1.substring(i, x));
			int b = y == j ? 0 : Integer.parseInt(version2.substring(j, y));
			if (a > b) {
				return 1;
			} else if (a < b) {
				return -1;
			}
			//比较完成后，将i，j向后移动
			i = x + 1;
			j = y + 1;
		}
		return 0;
	}
}
```



### 5.Leetcode 929 Unique Email Addresses

### 6.Leetcode 5 Longest Palindromic Substring 

### 7.Leetcode 6ZigZag Conversion

### 8.Leetcode 3 Longest Substring Without Repeating Characters

### 9.Leetcode 200 Number of Islands

### 10.Leetcode 273 Integer to English Words  

