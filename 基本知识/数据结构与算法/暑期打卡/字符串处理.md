# 字符串处理

## 题目

1. 38 Count and Say 
2. 49 Group Anagrams 
3. 151 Reverse Words in a String   
4. 165 Compare Version Numbers    
5. 929 Unique Email Addresses
6. 5 Longest Palindromic Substring 
7. 6ZigZag Conversion
8. 3 Longest Substring Without Repeating Characters
9. 200 Number of Islands
10. 273 Integer to English Words  

## 题解

### 1.Leetcode 38 Count and Say 

```java
class Solution {
	public String countAndSay(int n) {

		//result是最后的返回结果
		StringBuffer result = new StringBuffer("1");
		//因为n大于等于1，所以不用考虑n等于1
		//i用于控制循环次数
		for (int i = 0; i < n - 1; i++) {
			//临时变量，用于存储中间计算结果
			StringBuffer temp = new StringBuffer();
			//循环，对当前字符串进行计算
			for (int j = 0; j < result.length(); j++) {
				//k用于计算当前字符的重复次数（个数）
				int k = j;
				//循环，统计当前字符出现的次数
				while (k < result.length() && result.charAt(k) == result.charAt(j)) {
					k++;
				}

				//将计算结果追加到临时变量中
				temp.append(k - j);
				temp.append(result.charAt(j));
				//j回退
				j = k - 1;
			}
			//将中间计算结果，赋值给最终结果
			result = temp;
		}
		//返回最终结果
		return result.toString();
	}
}
```



### 2.Leetcode  49 Group Anagrams 

思路：

1. 判断字符串是否为空，如果为空，返回一个空集合

2. 对传入的字符串数组进行遍历：

   1. 申请一个map，用于存储所有的排序后的字符串，以及此字符串的字母异位词
   2. 将每一个字符串转换为字符数组
   3. 对字符数组进行排序
   4. 将排序后的字符数组转换为字符串
   5. 如果map中没有把当前排序后的字符串作为key保存，则将当前排序后的字符串作为key保存在map中，并申请一个list作为对应的value
   6. 将之前遍历的未排序的字符串添加到对应的map中

3. 返回一个集合，集合中的元素是map中的所有value，而每一个value是一个集合

   使用排序 + 哈希完成：

```java
class Solution {
	public List<List<String>> groupAnagrams(String[] strs) {
		//判断字符串是否为空，如果为空，返回一个空的集合
		if (strs.length == 0) {
			return new ArrayList<>();
		}

		//使用map来存储每一种字符串，以及此种字符串对应的字母异位词
		Map<String, List<String>> ans = new HashMap<>();
		//遍历字符串数组
		for (String str : strs) {
			//将每一个字符串转换为字符数组
			char[] chars = str.toCharArray();
			//对字符数组进行排序
			Arrays.sort(chars);
			//将排序后的字符数组转换为字符串
			String key = String.valueOf(chars);
			//如果map中没有保存当前的排序过的字符串，就将当前字符串作为key存储在map中
			if (!ans.containsKey(key)) {
				ans.put(key, new ArrayList<>());
			}
			//将之前遍历到的字符串装填到对应的map中
			ans.get(key).add(str);
		}
		//将map中的所有value值取出，放在一个集合中，并返回
		return new ArrayList<>(ans.values());
	}
}
```

使用记数法 + 哈希来分组：

```java
class Solution {
	public List<List<String>> groupAnagrams(String[] strs) {

		if (strs.length == 0) {
			return new ArrayList<>();
		}

		Map<String, List<String>> map = new HashMap<>();
		//定义一个数组，来记录每个字符串中字母出现的次数
		int[] count = new int[26];
		for (String str : strs) {
			//将数组初始化为全0
			Arrays.fill(count, 0);
			//遍历字符串中的每一个字符，记录出现的次数
			for (char c : str.toCharArray()) {
				count[c - 'a']++;
			}

			//格式化：将count数组转换为字符串，作为map中的key
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < 26; i++) {
				stringBuilder.append("#").append(count[i]);
			}
			String key = stringBuilder.toString();
			
			if (!map.containsKey(key)) {
				map.put(key, new ArrayList<>());
			}
			//将原字符串放入map中
			map.get(key).add(str);
		}
		
		return new ArrayList<>(map.values());
	}
}
```



### 3.Leetcode  151 Reverse Words in a String   

```java
class Solution {
	public String reverseWords(String s) {

		//将字符串按照空格拆分，转为字符串数组
		String[] data = s.split(" ");

		//去掉数组中的空字符串，并将剩余的字符串拼在一起
		StringBuilder temp = new StringBuilder();
		for (String datum : data) {
			String trim = datum.trim();
			if (!"".equals(trim)) {
				//将数组中的每一个元素（一个字符串）取出，去空格，反转，追加到temp中，并追加空格
				temp.append(new StringBuilder(trim).reverse()).append(" ");
			}
		}
		//对整个temp字符串反转，去空格，返回
		return temp.reverse().toString().trim();
	}
}
```

```java
class Solution {
	public String reverseWords(String s) {

		//将字符串按照空格拆分，转为字符串数组
		String[] data = s.split(" ");

		//去掉数组中的空字符串，并将剩余的字符串拼在一起
		StringBuilder temp = new StringBuilder();
		for (String datum : data) {
			if (!"".equals(datum.trim())) {
				temp.append(datum.trim()).append(" ");
			}
		}

		//将新生成的字符串拆分为字符数组
		data = temp.toString().split(" ");
		//计算字符串数组的长度
		int length = data.length;

		StringBuilder result = new StringBuilder();
		//反转字符数组，并将反转后的字符数组拼接成字符串
		for (int i = length - 1; i >= 0; i--) {
			result.append(data[i]);
			result.append(" ");
		}
		//去掉最后的空格
		return result.substring(0, result.lastIndexOf(" "));
	}
}
```



### 4.Leetcode  165 Compare Version Numbers    

```java
class Solution {
	public int compareVersion(String version1, String version2) {
		// System.out.println("version1 = " + version1);
		// System.out.println("version2 = " + version2);

		//拆分字符串
		String[] version1Array = version1.split("\\.");
		String[] version2Array = version2.split("\\.");

		// System.out.println("version1Array = " + Arrays.toString(version1Array));
		// System.out.println("version2Array = " + Arrays.toString(version2Array));

		//计算两个数组中的最大长度
		int length = Math.max(version1Array.length, version2Array.length);
		//将字符串转为list
		List<String> version1List = new ArrayList<>(Arrays.asList(version1Array));
		List<String> version2List = new ArrayList<>(Arrays.asList(version2Array));

		//如果数组长度小于另一个数组长度，在集合中补0
		if (version1Array.length < length) {
			for (int i = version1Array.length; i < length; i++) {
				version1List.add("0");
			}
		}

		//如果数组长度小于另一个数组长度，在集合中补0
		if (version2Array.length < length) {
			for (int i = version2Array.length; i < length; i++) {
				version2List.add("0");
			}
		}

		// System.out.println("version1List = " + version1List);
		// System.out.println("version2List = " + version2List);
		
		//一次比较集合中的元素
		for (int i = 0; i < length; i++) {
			int temp1 = Integer.parseInt(version1List.get(i));
			int temp2 = Integer.parseInt(version2List.get(i));
			if (temp1 > temp2) {
				return 1;
			} else if (temp1 < temp2) {
				return -1;
			}
		}

		return 0;
	}
}
```

```java
class Solution {
	public int compareVersion(String version1, String version2) {
		//i,j用于控制循环
		int i = 0;
		int j = 0;
		while (i < version1.length() || j < version2.length()) {
			int x = i;
			int y = j;
			//x，y用于取出一个或一段数字
			while (x < version1.length() && version1.charAt(x) != '.') x++;
			while (y < version2.length() && version2.charAt(y) != '.') y++;
			//a，b用于存储待比较的数字
			int a = x == i ? 0 : Integer.parseInt(version1.substring(i, x));
			int b = y == j ? 0 : Integer.parseInt(version2.substring(j, y));
			if (a > b) {
				return 1;
			} else if (a < b) {
				return -1;
			}
			//比较完成后，将i，j向后移动
			i = x + 1;
			j = y + 1;
		}
		return 0;
	}
}
```



### 5.Leetcode 929 Unique Email Addresses

```java
class Solution {
    public int numUniqueEmails(String[] emails) {
        if (emails.length == 0) return 0;

        //申请一个set，用于存储处理后的邮箱地址
        Set<String> set = new HashSet<>();
        //遍历邮箱地址
        for (String email : emails) {
            //以“@”符号为分界线，前半部分是local（local不包含“@”）
            String local = email.substring(0, email.indexOf("@"));
            //以“@”符号为分界线，后半部分是domain（domain包含“@”）
            String domain = email.substring(email.indexOf("@"));
            //如果local部分包含“+”号
            if (local.contains("+")) {
                //截取“+”号前面的字符串作为local
                local = local.substring(0, local.indexOf("+"));
            }
            //将local中的所有小数点去掉
            local = local.replaceAll("\\.", "");
            //将处理后的local与domain，连接在一起，存入set中
            set.add(local + domain);
        }
        //返回set的大小（此处，set有自动去重功能）
        return set.size();
    }
}

```



### 6.Leetcode 5 Longest Palindromic Substring 

使用蛮力法求解：

```java
class Solution {
    public String longestPalindrome(String s) {
        //定义返回变量
        String res = "";
        //获取字符串长度
        int length = s.length();
        //遍历字符串
        for (int i = 0; i < length; i++) {
            //如果字符串长度是奇数
            //左右指针均从i开始，左指针大于或等于0，右指针小于字符串长度，如果左右指针所指向的字符相等，左右指针分别向左右移动
            for (int left = i, right = i; left >= 0 && right < length && s.charAt(left) == s.charAt(right); left--, right++) {
                //如果当前res的长度，小于目前的回文串长度
                if (res.length() < right - left + 1) {
                    //更新返回结果
                    res = s.substring(left, right + 1);
                }
            }
            //如果字符串长度是偶数
            //轴字符为两个，所以右指针起点是i+1
            for (int left = i, right = i + 1; left >= 0 && right < length && s.charAt(left) == s.charAt(right); left--, right++) {
                if (res.length() < right - left + 1) {
                    res = s.substring(left, right + 1);
                }
            }
        }
        //返回结果
        return res;
    }
}
```



```java
class Solution {
	public String longestPalindrome(String s) {
		if (s == null || "".equals(s) || s.length() < 1) {
			return "";
		}


		int start = 0;
		int end = 0;
		int sLength = s.length();
		for (int i = 0; i < sLength; i++) {
			int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
			int len = Math.max(len1, len2);
			if (len > end - start) {
				start = i - (len - 1) / 2;
				end = i + len / 2;
			}
		}
		return s.substring(start, end + 1);
	}

	private int expandAroundCenter(String s, int left, int right) {
		int L = left;
		int R = right;

		while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
			L--;
			R++;
		}

		return R - L - 1;
	}
}
```



### 7.Leetcode 6ZigZag Conversion

```java
class Solution {
    public String convert(String s, int numRows) {
        //如果只有一行，直接返回字符串，不用处理
		if (numRows == 1) {
			return s;
		}

		//新建一个List，大小为行数与字符串长度中较小的一个
		List<StringBuilder> rows = new ArrayList<>();
		int len = Math.min(s.length(), numRows);
		//List中的每一个元素是一个StringBuilder，用于存储每一行
		for (int i = 0; i < len; i++) {
			rows.add(new StringBuilder());
		}

		//将原字符串变为字符数组
		char[] data = s.toCharArray();

		//向下遍历的标志
		boolean goingDown = false;
		//初始化当前行
		int currentRow = 0;
		
		//遍历字符数组，将每一个字符存储在对应的StringBuilder中
		for (char c : data) {
			rows.get(currentRow).append(c);
			//当当前行为0（第一行）或者为numRows-1（最后一行）时，需要调换方向
			if (currentRow == 0 || currentRow == numRows - 1) {
				goingDown = !goingDown;
			}
			//根据遍历的方向，决定行数的变化
			currentRow += goingDown ? 1 : -1;
		}
		
		//合并所有的StringBuilder，返回结果
		StringBuilder result = new StringBuilder();
		for (StringBuilder row : rows) {
			result.append(row);
		}
		return result.toString();
	}
    
}
```



### 8.Leetcode 3 Longest Substring Without Repeating Characters

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int result = 0;

        Map<Character, Integer> map = new HashMap<>();

        for (int left = 0, right = 0; right < s.length(); right++) {
            //如果map中包含了当前字符
            if (map.containsKey(s.charAt(right))) {
                //更新left：当前子串中s.charAt(right)+1
                left = Math.max(left, map.get(s.charAt(right)));
            }
            //把当前字符加入到map中
            map.put(s.charAt(right), right + 1);
            //更新结果
            result = Math.max(result, right - left + 1);
        }
        return result;
    }
}
```



### 9.Leetcode 200 Number of Islands

### 10.Leetcode 273 Integer to English Words  

