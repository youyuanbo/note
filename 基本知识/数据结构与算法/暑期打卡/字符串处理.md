# 字符串处理

## 题目

1. Leetcode38 Count and Say 
2. Leetcode49 Group Anagrams 
3. Leetcode151 Reverse Words in a String   
4. Leetcode165 Compare Version Numbers    
5. Leetcode929 Unique Email Addresses
6. Leetcode5 Longest Palindromic Substring 
7. Leetcode6ZigZag Conversion
8. Leetcode3 Longest Substring Without Repeating Characters
9. Leetcode208 Implement Trie (Prefix Tree) 
10. Leetcode273 Integer to English Words  

## 题解

### 1.Leetcode 38 Count and Say 

思路：

1. 在本题中，需要循环n-1次，而不是n次
   1. 在内层循环中，需要对上次处理后的结果进行处理
   2. 在循环中，需要统计从当前字符起，并且与当前字符相等的字符数
   3. 将统计的结果和当前字符存入临时变量中，每次循环循环结束，都需要更新返回结果

```java
class Solution {
	public String countAndSay(int n) {

		//result是最后的返回结果
		StringBuffer result = new StringBuffer("1");
		//因为n大于等于1，所以不用考虑n等于1
		//i用于控制循环次数
		for (int i = 0; i < n - 1; i++) {
			//临时变量，用于存储中间计算结果
			StringBuffer temp = new StringBuffer();
			//循环，对当前字符串进行计算
			for (int j = 0; j < result.length(); j++) {
				//k用于计算当前字符的重复次数（个数）
				int k = j;
				//循环，统计当前字符出现的次数
				while (k < result.length() && result.charAt(k) == result.charAt(j)) {
					k++;
				}

				//将计算结果追加到临时变量中
				temp.append(k - j);
				temp.append(result.charAt(j));
				//j回退
				j = k - 1;
			}
			//将中间计算结果，赋值给最终结果
			result = temp;
		}
		//返回最终结果
		return result.toString();
	}
}
```



### 2.Leetcode  49 Group Anagrams 

思路：

1. 判断字符串是否为空，如果为空，返回一个空集合

2. 对传入的字符串数组进行遍历：

   1. 申请一个map，用于存储所有的排序后的字符串，以及此字符串的字母异位词
   2. 将每一个字符串转换为字符数组
   3. 对字符数组进行排序
   4. 将排序后的字符数组转换为字符串
   5. 如果map中没有把当前排序后的字符串作为key保存，则将当前排序后的字符串作为key保存在map中，并申请一个list作为对应的value
   6. 将之前遍历的未排序的字符串添加到对应的map中

3. 返回一个集合，集合中的元素是map中的所有value，而每一个value是一个集合

   使用排序 + 哈希完成：

```java
class Solution {
	public List<List<String>> groupAnagrams(String[] strs) {
		//判断字符串是否为空，如果为空，返回一个空的集合
		if (strs.length == 0) {
			return new ArrayList<>();
		}

		//使用map来存储每一种字符串，以及此种字符串对应的字母异位词
		Map<String, List<String>> ans = new HashMap<>();
		//遍历字符串数组
		for (String str : strs) {
			//将每一个字符串转换为字符数组
			char[] chars = str.toCharArray();
			//对字符数组进行排序
			Arrays.sort(chars);
			//将排序后的字符数组转换为字符串
			String key = String.valueOf(chars);
			//如果map中没有保存当前的排序过的字符串，就将当前字符串作为key存储在map中
			if (!ans.containsKey(key)) {
				ans.put(key, new ArrayList<>());
			}
			//将之前遍历到的字符串装填到对应的map中
			ans.get(key).add(str);
		}
		//将map中的所有value值取出，放在一个集合中，并返回
		return new ArrayList<>(ans.values());
	}
}
```

使用记数法 + 哈希来分组：

```java
class Solution {
	public List<List<String>> groupAnagrams(String[] strs) {

		if (strs.length == 0) {
			return new ArrayList<>();
		}

		Map<String, List<String>> map = new HashMap<>();
		//定义一个数组，来记录每个字符串中字母出现的次数
		int[] count = new int[26];
		for (String str : strs) {
			//将数组初始化为全0
			Arrays.fill(count, 0);
			//遍历字符串中的每一个字符，记录出现的次数
			for (char c : str.toCharArray()) {
				count[c - 'a']++;
			}

			//格式化：将count数组转换为字符串，作为map中的key
			StringBuilder stringBuilder = new StringBuilder();
			for (int i = 0; i < 26; i++) {
				stringBuilder.append("#").append(count[i]);
			}
			String key = stringBuilder.toString();
			
			if (!map.containsKey(key)) {
				map.put(key, new ArrayList<>());
			}
			//将原字符串放入map中
			map.get(key).add(str);
		}
		
		return new ArrayList<>(map.values());
	}
}
```



### 3.Leetcode  151 Reverse Words in a String   

思路：

1. 将字符串按照空格分隔成字符串数组
2. 遍历字符串数组，去掉数组中的空格字符串，并把非空格字符串的多余空格去掉
3. 把处理后的字符串数组中的每一个元素反转，并追加一个空格
4. 把反转后的字符串连接在一起
5. 把连接在一起的字符串反转，并返回结果

```java
class Solution {
	public String reverseWords(String s) {

		//将字符串按照空格拆分，转为字符串数组
		String[] data = s.split(" ");

		//去掉数组中的空字符串，并将剩余的字符串拼在一起
		StringBuilder temp = new StringBuilder();
		for (String datum : data) {
			String trim = datum.trim();
			if (!"".equals(trim)) {
				//将数组中的每一个元素（一个字符串）取出，去空格，反转，追加到temp中，并追加空格
				temp.append(new StringBuilder(trim).reverse()).append(" ");
			}
		}
		//对整个temp字符串反转，去空格，返回
		return temp.reverse().toString().trim();
	}
}
```

思路：

1. 将字符串按照空格拆分字符串数组
2. 去掉数组中的空格字符串，以及字符串中两边余的空格
3. 将去掉多余空格的字符串连接在一起，中间用一个空格分隔
4. 再次按照空格把字符串拆分成字符串数组
5. 从后往前遍历数组，把取出来的每一个字符串连接在一起，字符串之间用空格分隔
6. 去掉最后添加的空格，并返回结果

```java
class Solution {
	public String reverseWords(String s) {

		//将字符串按照空格拆分，转为字符串数组
		String[] data = s.split(" ");

		//去掉数组中的空字符串，并将剩余的字符串拼在一起
		StringBuilder temp = new StringBuilder();
		for (String datum : data) {
			if (!"".equals(datum.trim())) {
				temp.append(datum.trim()).append(" ");
			}
		}
        
		//将新生成的字符串拆分为字符数组
		data = temp.toString().split(" ");
		//计算字符串数组的长度
		int length = data.length;

		StringBuilder result = new StringBuilder();
		//反转字符数组，并将反转后的字符数组拼接成字符串
		for (int i = length - 1; i >= 0; i--) {
			result.append(data[i]);
			result.append(" ");
		}
		//去掉最后的空格
		return result.substring(0, result.lastIndexOf(" "));
	}
}
```



### 4.Leetcode  165 Compare Version Numbers    

思路：

1. 按照小数点将字符串拆分成字符数组，以较大的数组长度为准，把短的数组扩大，用0填充扩大部分
2. 遍历数组，依次比较元素的大小
3. 返回结果

```java
class Solution {
	public int compareVersion(String version1, String version2) {
		// System.out.println("version1 = " + version1);
		// System.out.println("version2 = " + version2);

		//拆分字符串
		String[] version1Array = version1.split("\\.");
		String[] version2Array = version2.split("\\.");

		// System.out.println("version1Array = " + Arrays.toString(version1Array));
		// System.out.println("version2Array = " + Arrays.toString(version2Array));

		//计算两个数组中的最大长度
		int length = Math.max(version1Array.length, version2Array.length);
		//将字符串转为list
		List<String> version1List = new ArrayList<>(Arrays.asList(version1Array));
		List<String> version2List = new ArrayList<>(Arrays.asList(version2Array));

		//如果数组长度小于另一个数组长度，在集合中补0
		if (version1Array.length < length) {
			for (int i = version1Array.length; i < length; i++) {
				version1List.add("0");
			}
		}

		//如果数组长度小于另一个数组长度，在集合中补0
		if (version2Array.length < length) {
			for (int i = version2Array.length; i < length; i++) {
				version2List.add("0");
			}
		}

		// System.out.println("version1List = " + version1List);
		// System.out.println("version2List = " + version2List);
		
		//一次比较集合中的元素
		for (int i = 0; i < length; i++) {
			int temp1 = Integer.parseInt(version1List.get(i));
			int temp2 = Integer.parseInt(version2List.get(i));
			if (temp1 > temp2) {
				return 1;
			} else if (temp1 < temp2) {
				return -1;
			}
		}

		return 0;
	}
}
```

```java
class Solution {
	public int compareVersion(String version1, String version2) {
		//i,j用于控制循环
		int i = 0;
		int j = 0;
		while (i < version1.length() || j < version2.length()) {
			int x = i;
			int y = j;
			//x，y用于取出一个或一段数字
			while (x < version1.length() && version1.charAt(x) != '.') x++;
			while (y < version2.length() && version2.charAt(y) != '.') y++;
			//a，b用于存储待比较的数字
			int a = x == i ? 0 : Integer.parseInt(version1.substring(i, x));
			int b = y == j ? 0 : Integer.parseInt(version2.substring(j, y));
			if (a > b) {
				return 1;
			} else if (a < b) {
				return -1;
			}
			//比较完成后，将i，j向后移动
			i = x + 1;
			j = y + 1;
		}
		return 0;
	}
}
```



### 5.Leetcode 929 Unique Email Addresses

思路：

1. 以“@”为分隔，将邮箱地址分隔为local与domain（domain包含“@”）
2. 如果local中包含“+”，截取“+”前面的部分，赋值给local
3. 如果local中存在小数点，去除local中的所有小数点
4. 把local与domain重新连接起来，存入set中
5. 返回set的大小

```java
class Solution {
    public int numUniqueEmails(String[] emails) {
        if (emails.length == 0) return 0;

        //申请一个set，用于存储处理后的邮箱地址
        Set<String> set = new HashSet<>();
        //遍历邮箱地址
        for (String email : emails) {
            //以“@”符号为分界线，前半部分是local（local不包含“@”）
            String local = email.substring(0, email.indexOf("@"));
            //以“@”符号为分界线，后半部分是domain（domain包含“@”）
            String domain = email.substring(email.indexOf("@"));
            //如果local部分包含“+”号
            if (local.contains("+")) {
                //截取“+”号前面的字符串作为local
                local = local.substring(0, local.indexOf("+"));
            }
            //将local中的所有小数点去掉
            local = local.replaceAll("\\.", "");
            //将处理后的local与domain，连接在一起，存入set中
            set.add(local + domain);
        }
        //返回set的大小（此处，set有自动去重功能）
        return set.size();
    }
}

```



### 6.Leetcode 5 Longest Palindromic Substring 

使用蛮力法求解：

```java
class Solution {
    public String longestPalindrome(String s) {
        //定义返回变量
        String res = "";
        //获取字符串长度
        int length = s.length();
        //遍历字符串
        for (int i = 0; i < length; i++) {
            //如果字符串长度是奇数
            //左右指针均从i开始，左指针大于或等于0，右指针小于字符串长度，如果左右指针所指向的字符相等，左右指针分别向左右移动
            for (int left = i, right = i; left >= 0 && right < length && s.charAt(left) == s.charAt(right); left--, right++) {
                //如果当前res的长度，小于目前的回文串长度
                if (res.length() < right - left + 1) {
                    //更新返回结果
                    res = s.substring(left, right + 1);
                }
            }
            //如果字符串长度是偶数
            //轴字符为两个，所以右指针起点是i+1
            for (int left = i, right = i + 1; left >= 0 && right < length && s.charAt(left) == s.charAt(right); left--, right++) {
                if (res.length() < right - left + 1) {
                    res = s.substring(left, right + 1);
                }
            }
        }
        //返回结果
        return res;
    }
}
```



```java
class Solution {
	public String longestPalindrome(String s) {
		if (s == null || "".equals(s) || s.length() < 1) {
			return "";
		}
		int start = 0;
		int end = 0;
		int sLength = s.length();
		for (int i = 0; i < sLength; i++) {
			int len1 = expandAroundCenter(s, i, i);
            int len2 = expandAroundCenter(s, i, i + 1);
			int len = Math.max(len1, len2);
			if (len > end - start) {
				start = i - (len - 1) / 2;
				end = i + len / 2;
			}
		}
		return s.substring(start, end + 1);
	}

	private int expandAroundCenter(String s, int left, int right) {
		int L = left;
		int R = right;

		while (L >= 0 && R < s.length() && s.charAt(L) == s.charAt(R)) {
			L--;
			R++;
		}

		return R - L - 1;
	}
}
```



### 7.Leetcode 6ZigZag Conversion

```java
class Solution {
    public String convert(String s, int numRows) {
        //如果只有一行，直接返回字符串，不用处理
		if (numRows == 1) {
			return s;
		}

		//新建一个List，大小为行数与字符串长度中较小的一个
		List<StringBuilder> rows = new ArrayList<>();
		int len = Math.min(s.length(), numRows);
		//List中的每一个元素是一个StringBuilder，用于存储每一行
		for (int i = 0; i < len; i++) {
			rows.add(new StringBuilder());
		}

		//将原字符串变为字符数组
		char[] data = s.toCharArray();

		//向下遍历的标志
		boolean goingDown = false;
		//初始化当前行
		int currentRow = 0;
		
		//遍历字符数组，将每一个字符存储在对应的StringBuilder中
		for (char c : data) {
			rows.get(currentRow).append(c);
			//当当前行为0（第一行）或者为numRows-1（最后一行）时，需要调换方向
			if (currentRow == 0 || currentRow == numRows - 1) {
				goingDown = !goingDown;
			}
			//根据遍历的方向，决定行数的变化
			currentRow += goingDown ? 1 : -1;
		}
		
		//合并所有的StringBuilder，返回结果
		StringBuilder result = new StringBuilder();
		for (StringBuilder row : rows) {
			result.append(row);
		}
		return result.toString();
	}
    
}
```



### 8.Leetcode 3 Longest Substring Without Repeating Characters

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int result = 0;

        Map<Character, Integer> map = new HashMap<>();

        for (int left = 0, right = 0; right < s.length(); right++) {
            //如果map中包含了当前字符
            if (map.containsKey(s.charAt(right))) {
                //更新left：当前子串中s.charAt(right)+1
                left = Math.max(left, map.get(s.charAt(right)));
            }
            //把当前字符加入到map中
            map.put(s.charAt(right), right + 1);
            //更新结果
            result = Math.max(result, right - left + 1);
        }
        return result;
    }
}
```



### 9.Leetcode 208 Implement Trie (Prefix Tree) 

```java
public class Trie {

    class Node {
        boolean isEnd;
		//用一个数组，存储所有的分支
        Node[] son = new Node[26];
        Node() {

            this.isEnd = false;
            for (int i = 0; i < 26; i++) {
                this.son[i] = null;
            }
        }
    }

    Node root;

    /**
     * Initialize your data structure here.
     */
    public Trie() {
        this.root = new Node();
    }

    /**
     * Inserts a word into the trie.
     */
    public void insert(String word) {
        Node curr = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (curr.son[index] == null) curr.son[index] = new Node();
            curr = curr.son[index];
        }
        curr.isEnd = true;
    }

    /**
     * Returns if the word is in the trie.
     */
    public boolean search(String word) {
        Node curr = root;
        for (char c : word.toCharArray()) {
            int index = c - 'a';
            if (curr.son[index] == null) return false;
            curr = curr.son[index];
        }
        return curr.isEnd;
    }

    /**
     * Returns if there is any word in the trie that starts with the given prefix.
     */
    public boolean startsWith(String prefix) {
        Node curr = root;
        for (char c : prefix.toCharArray()) {
            int index = c - 'a';
            if (curr.son[index] == null) return false;
            curr = curr.son[index];
        }
        return true;
    }
}
```



### 10.Leetcode 273 Integer to English Words  

思路：

1. 初始化数据：定义三个字符串数组，用于保存0~20数字对应的英文单词、整十数英文单词、以及十亿、百万、千
2. 将传入的数据按照每3为划分一次，传入getPart函数做处理：
   1. 申明一个String类型的变量，用来保存处理结果
   2. 如果num大于100，需要将百位上的数字对应的英文单词取出，赋值给result，并添加单位与空格
   3. 百位处理后，需要判断num是否等于0。如果num等于0，可以直接返回result
   4. 如果百位处理，num大于20,需要将十位上的数字对应的英文单词取出，赋值给result，并添加空格
   5. 十位处理后，需要判断num是否等于0。如果num等于0，可以直接返回result
   6. 如果在第2、4步处理后，num小于20，或者传入的num小于20，应直接取出num对应的英文单词，并返回result

```java
class Solution {

    String small[] = {"Zero", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten",
            "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen"};
    String decade[] = {"", "", "Twenty", "Thirty", "Forty", "Fifty", "Sixty", "Seventy", "Eighty", "Ninety"};
    String big[] = {"Billion", "Million", "Thousand", ""};

    public String numberToWords(int num) {
        //如果传入的num小于或等于0，返回zero
        if (num <= 0) {
            return small[0];
        }

        //定义返回结果变量
        StringBuilder result = new StringBuilder();
        //最大数假设为10亿，每3位数一次划分
        for (int i = 1000000000, j = 0; i > 0; i /= 1000, j++) {
            //如果当前数大于i，说明需要将高位做处理，高位数最大值是999
            if (num >= i) {
                //将高位数传入getPart函数中，做处理，在处理完成后，需要在后面添加单位，并添加空格
                result.append(getPart(num / i)).append(big[j]).append(" ");
                //处理完成后，需要更新num值，将高位数去掉
                num %= i;
            }
        }
        //去除结果中多余的空格
        result = new StringBuilder(result.toString().trim());
        //返回结果
        return result.toString();

    }

    /**
     * 处理传入的数据
     *
     * @param num 参数，最大值是999
     * @return 返回处理后的结果，num的英文读法
     */
    public String getPart(int num) {
        //定义返回结果变量
        String result = "";
        //如果num大于或等于100
        if (num >= 100) {
            //取出百位数对应的英文单词，赋值给result，并添加单位和空格
            result += small[num / 100] + " Hundred" + " ";
            //更新num值，去掉百位数
            num %= 100;
        }

        //如果处理百位数之后，num为0，直接返回result
        if (num == 0) return result;
        //如果处理百位数之后，nun大于或等于20
        if (num >= 20) {
            //取出十位上的数字对应的英文，并添加空格
            result += decade[num / 10] + " ";
            //更新num值，去掉十位上的数字
            num %= 10;
        }
        //如果处理十位上的数字之后，num等于9，直接返回result
        if (num == 0) return result;
        //如果传入的num值小于20、或者在处理完百位数和十位数、或者在处理完百位数或十位数后，num小于20
        //取出num对应的英文单词，赋值给result
        result += small[num] + " ";
        //返回result
        return result;
    }
}
```



