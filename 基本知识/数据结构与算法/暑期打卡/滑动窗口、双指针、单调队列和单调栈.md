# 滑动窗口、双指针、单调队列和单调栈

## 知识点

1. 单点栈：查找每个数左侧第一个比它小（大等等）的数
2. 单调队列：滑动窗口的最值

## 题目列表

1. Leetcode 167 Two Sum II - Input array is sorted
2. Leetcode 88 Merge Sorted Array
3. Leetcode 26 Remove Duplicates from Sorted Array 
4. Leetcode 76 Minimum Window Substring
5. Leetcode 32 Longest Valid Parentheses 
6. Leetcode 155 Min Stack 
7. Leetcode 42 Trapping Rain Water 
8. Leetcode 84 Largest Rectangle in Histogram
9. Leetcode 239 Sliding Window Maximum  
10. Leetcode 918 Maximum Sum Circular Subarray 

## 题解

### Leetcode 167 Two Sum II - Input array is sorted

1. 题目详情：

2. 题解思路

   1. 使用双指针

      + 定义左指针初始化在最左边，向右运动；定义右指针初始化在最右边，向左运动
      + 使用while循环，循环条件时left < right
        + 每次取出left指针所指元素（numbers[left]）与right指针所指元素（numbers[right]），如果两元素之和等于target，将left与right的值存在result数组中，并返回
        + 如果两元素之和大于target，right向左移动
        + 如果两元素之和小于target，left向右移动

      ```java
      //使用双指针完成
      class Solution {
          public int[] twoSum(int[] numbers, int target) {
      
              int[] result = new int[2];
              int numLength = numbers.length;
              int left = 0;
              int right = numLength - 1;
              while (left < right) {
                  int sum = numbers[left] + numbers[right];
                  if (sum == target) {
                      result[0] = left + 1;
                      result[1] = right + 1;
                      return result;
                  } else if (sum > target) {
                      right--;
                  } else {
                      left++;
                  }
              }
              return result;
          }
      }
      ```

      

   2. 使用两次hash

      + 将数组中的元素作为key，元素在数组中的下标作为value存入一个hashmap中
      + 循环number.length次
        + 判断map中是否存在key（target-number [i] ）
        + 如果存在，将i作为result的第一个元素，将map.get(target-number[i])作为result的第二个元素，并返回result
        + 如果不存在，进入下一次循环

      ```java
      //使用两次hash完成
      class Solution {
          public int[] twoSum(int[] numbers, int target) {
              int[] result = new int[2];
              int numLength = numbers.length;
              Map<Integer, Integer> map = new HashMap<>();
              for (int i = 0; i < numLength; i++) {
                  map.put(numbers[i], i);
              }
      
              for (int i = 0; i < numLength; i++) {
                  int temp = target - numbers[i];
                  if (map.containsKey(temp) && map.get(temp) != i) {
                      result[0] = i + 1;
                      result[1] = map.get(temp) + 1;
                      return result;
                  }
              }
              return result;
          }
      }
      ```

      

   3. 使用一次hash

      + 循环number.length次
        + 判断map中是否存在key（target-number[i]）
        + 如果存在，将map.get(target-number[i])作为result的第一个元素，i作为result的第二个元素，并返回result
        + 如果不存在，将（number[i], i）存入map中
      + 返回result

      ```java
      //使用一次hash完成
      class Solution {
          public int[] twoSum(int[] numbers, int target) {
              int[] result = new int[2];
              int numLength = numbers.length;
              Map<Integer, Integer> map = new HashMap<>();
      
              for (int i = 0; i < numLength; i++) {
                  int temp = target - numbers[i];
                  if (map.containsKey(temp)) {
                      result[0] = map.get(temp) + 1;
                      result[1] = i + 1;
                      return result;
                  }
      
                  map.put(numbers[i], i);
              }
              return result;
          }
      }
      ```

      

      



### Leetcode 88 Merge Sorted Array



题解：

使用移动合并

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        //如果m=0，说明nums1中没有元素
        if (m == 0) {
            //如果n=0,说明num2中没有元素，不用合并
            if (n == 0) {
                return;
            }
            //如果m=0，n != 0，将num2中的元素复制到num1中即可
            for (int i = 0; i < n; i++) {
                nums1[i] = nums2[i];
            }
            return;
        }

        //遍历nums2
        for (int i = 0; i < n; i++) {
            //取出当前需要合并的元素
            int ele2 = nums2[i];
            //遍历num1，确定ele2应该插入的位置，并插入ele2
            for (int j = m - 1; j >= 0; j--) {

                if (nums1[j] <= ele2) {
                    nums1[j + 1] = ele2;
                    break;
                }
                //如果num1[j]大于ele2，将数据向后移动
                nums1[j + 1] = nums1[j];
                nums1[j] = ele2;
            }
            //插入完一个数据后，需要将m更新
            m++;
        }

    }
}
```

双指针，需要额外开辟空间

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int[] num1_copy = new int[m];
        System.arraycopy(nums1, 0, num1_copy, 0, m);

        int p1 = 0;
        int p2 = 0;
        int p = 0;
        while (p1 < m && p2 < n) {
            nums1[p++] = num1_copy[p1] < nums2[p2] ? num1_copy[p1++] : nums2[p2++];
        }

        if (p1 < m) {
            System.arraycopy(num1_copy, p1, nums1, p1 + p2, m - p1);
        }
        if (p2 < n) {
            System.arraycopy(nums2, p2, nums1, p1 + p2, n - p2);
        }
    }
}
```

双指针，不需要额外开辟空间

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        //p1指向num1数组中，最后一个元素（不是0）
        int p1 = m - 1;
        //p2指向num2数组中，最后一个元素
        int p2 = n - 1;
        //p指向num1数组的最后一个单元（可能是0）
        int p = m + n - 1;
        //循环，只要num1或者num2数组遍历完成，就会结束循环
        while (p1 >= 0 && p2 >= 0) {
            nums1[p--] = nums1[p1] > nums2[p2] ? nums1[p1--] : nums2[p2--];

        }
        //将num2中没有合并完的数据，添加到num1中
        System.arraycopy(nums2, 0, nums1, 0, p2 + 1);
    }
}
```

### Leetcode 26 Remove Duplicates from Sorted Array 



```java
class Solution {
    public int removeDuplicates(int[] nums) {
        //如果数组为空，返回0
        if (nums.length == 0) {
            return 0;
        }
        //定义慢指针uniqueElement 
        int uniqueElement = 0;
        //遍历数组，定义快指针i
        for (int i = 0; i < nums.length; i++) {
            //如果快指针与慢指针所指元素不相等
            if (nums[uniqueElement] != nums[i]) {
                //将慢指针向后移动
                uniqueElement++;
                //将快指针所指元素赋值给慢指针所指位置
                nums[uniqueElement] = nums[i];
            }
        }
        //添加最后的不相等元素
        uniqueElement++;
        //返回
        return uniqueElement;
    }
}
```



### Leetcode 76 Minimum Window Substring

Problem

Solution

采用滑动窗口解决

1. 初始化：
   1. 定义一个HashMap（dictT），key是字符串T中不重复的字符，value是该字符在字符串T中出现的次数
   2. 定义一个HashMap（windowCounts），用来充当滑动窗口，key是加入的非重复字符，value是该字符串当前出现的次数
   3. 定义一个整型数组res，包含三个元素：最小窗口的长度，左指针位置，右指针位置，初始化都为0
   4. 定义整型变量：左指针，右指针，默认都是0；required，字符串T中非重复字符数（dictT的大小）；formed，滑动串口中已经添加的需要的非重复字符
2. 算法
   1. 初始化：left与right指针都指向S的第一个元素
   2. 将right指针向右移动，扩张窗口，直到找到一个可行窗口，亦即包含T的所有字符的窗口，记录此窗口
   3. 得到可行串口后，将left指针逐个向右移动，若得到的串口依然可行，则更新最小窗口
   4. 如果窗口不可行，转2
3. 步骤
   1. 判断字符串S或T是否为空，如果有一个为空，返回一个空的字符串
   2. 将字符串T中所有字符加入dictT中，并初始化其余变量
   3. 以右指针为主，遍历字符串S
      1. 取出当前字符，并添加到滑动窗口中，注意value需要在原有值上加1
      2. 判断此字符是否已经满足：此字符串存在于字符串T中，此字符在T中的出现次数与在S中出现次数一致。如满足，formed++
      3. 如果满足left<=right && formed == required（已经找到了一个解）
         1. 取出S中left所指向的字符
         2. 判断是否需要更新res（条件：res [0] = -1 || res [0] < right - left + 1）；如满足，更新
         3. 删除滑动窗口中的S[left]字符
         4. 判断删除后是否需要更新formed，条件：此字符串存在于字符串T中，此字符在T中的出现次数大于在S中出现次数。
         5. 更新left指针，将left指针向右移动
      4. 将right指针向右移动
      5. 循环结束后，返回

```java
class Solution {
    public String minWindow(String s, String t) {
        if (s.length() == 0 || t.length() == 0) {
            return "";
        }

        // Dictionary which keeps a count of all the unique characters in t.
        Map<Character, Integer> dictT = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            int count = dictT.getOrDefault(t.charAt(i), 0);
            dictT.put(t.charAt(i), count + 1);
        }

        // Number of unique characters in t, which need to be present in the desired window.
        int required = dictT.size();

        // Left and Right pointer
        int l = 0;
        int r = 0;

        // formed is used to keep track of how many unique characters in t.
        // are present in the current the window int its desired frequency.
        // e.g. if t is "AABC" then the window must have two 'A' , one 'B' and one 'C'
        // Thus formed would be 3 when all these conditions are met.
        int formed = 0;

        // Dictionary which keeps a count of all the unique characters in the current window.
        Map<Character, Integer> windowCounts = new HashMap<>();

        // ans list of the form (window length, left, right)
        int[] ans = {-1, 0, 0};

        while (r < s.length()) {
            // Add one character form the right to the window
            char c = s.charAt(r);
            int count = windowCounts.getOrDefault(c, 0);
            windowCounts.put(c, count + 1);

            // If the frequency of the current character added equals to the
            // desired count in t then increment the formed count by 1
            if (dictT.containsKey(c) && windowCounts.get(c).intValue() == dictT.get(c).intValue()) {
                formed++;
            }

            // Try and update the window till the point where it ceases to be 'desirable'.
            while (l <= r && formed == required) {
                c = s.charAt(l);
                // Save the smallest window until now.
                if (ans[0] == -1 || r - l + 1 < ans[0]) {
                    ans[0] = r - l + 1;
                    ans[1] = l;
                    ans[2] = r;
                }
                //The character at the position pointed by the 'Left' pointer
                // is no longer a part of the window
                windowCounts.put(c, windowCounts.get(c) - 1);
                if (dictT.containsKey(c) && windowCounts.get(c) < dictT.get(c)) {
                    formed--;
                }
                //Move the left pointer ahead, this would help to look for a new window.
                l++;
            }
            // Move the right pointer ahead, this would help to look a new window.
            r++;
        }
        return ans[0] == -1 ? "" : s.substring(ans[1], ans[2] + 1);
    }
}
```



```java
/**
 * 使用pair， 减少遍历S的次数
 */
class Solution {
    public String minWindow(String s, String t) {
        if (s.length() == 0 || t.length() == 0) {
            return "";
        }

        Map<Character, Integer> dictT = new HashMap<>();
        for (int i = 0; i < t.length(); i++) {
            int count = dictT.getOrDefault(t.charAt(i), 0);
            dictT.put(t.charAt(i), count + 1);
        }

        int required = dictT.size();

        int left = 0;
        int right = 0;
        int[] ans = {-1, 0, 0};
        int formed = 0;
        Map<Character, Integer> windowCounts = new HashMap<>();

        List<Pair<Integer, Character>> filteredS = new ArrayList<>();
        for (int i = 0; i < s.length(); i++) {
            char c = s.charAt(i);
            if (dictT.containsKey(c)) {
                filteredS.add(new Pair<>(i, c));
            }
        }

        while (right < filteredS.size()) {

            char c = filteredS.get(right).getValue();
            int count = windowCounts.getOrDefault(c, 0);
            windowCounts.put(c, count + 1);

            if (dictT.containsKey(c) && dictT.get(c).intValue() == windowCounts.get(c).intValue()) {
                formed++;
            }

            while (left <= right && required == formed) {

                c = filteredS.get(left).getValue();

                int end = filteredS.get(right).getKey();
                int start = filteredS.get(left).getKey();

                if (ans[0] == -1 || ans[0] > end - start + 1) {
                    ans[0] = end - start + 1;
                    ans[1] = start;
                    ans[2] = end;
                }

                windowCounts.put(c, windowCounts.get(c) - 1);
                if (dictT.containsKey(c) && dictT.get(c) > windowCounts.get(c)) {
                    formed--;
                }

                left++;
            }

            right++;
        }
        return ans[0] == -1 ? "" : s.substring(ans[1], ans[2] + 1);
    }
}
```



### Leetcode 32 Longest Valid Parentheses 

使用前缀和完成

```java
class Solution {
    public int longestValidParentheses(String s) {
        if (s.length() == 0) {
            return 0;
        }
        int result = work(s);

        s = new StringBuilder(s).reverse().toString();

        StringBuilder temp = new StringBuilder();
        for (int i = 0; i < s.length(); i++) {
            temp.append((char) (s.charAt(i) ^ 1));
        }

        return Math.max(result, work(temp.toString()));
    }

    private int work(String s) {
        int result = 0;
        for (int i = 0, start = 0, count = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                count++;
            } else {
                count--;
                if (count < 0) {
                    start = i + 1;
                    count = 0;
                } else if (count == 0) {
                    result = Math.max(result, i - start + 1);
                }
            }
        }
        return result;
    }
}
```



### Leetcode 155 Min Stack 

```java
public class MinStack {

    Stack<Integer> stack;
    Stack<Integer> min;


    /**
     * initialize your data structure here.
     */
    public MinStack() {
        stack = new Stack<>();
        min = new Stack<>();
    }

    public void push(int x) {
        stack.push(x);
        if (min.isEmpty()) {
            min.push(x);
        } else {
            min.push(Math.min(min.peek(), x));
        }

    }

    public void pop() {
        stack.pop();
        min.pop();
    }

    public int top() {
        return stack.peek();
    }

    public int getMin() {
        return min.peek();
    }

    public static void main(String[] args) {
        MinStack minStack = new MinStack();
        minStack.push(-2);
        minStack.push(0);
        minStack.push(-3);

        System.out.println("minStack.getMin() = " + minStack.getMin());
        minStack.pop();
        System.out.println("minStack.top() = " + minStack.top());
        System.out.println("minStack.getMin() = " + minStack.getMin());


    }
}
```



### Leetcode 42 Trapping Rain Water 



```java

class Solution {
    public int trap(int[] height) {
        //result是最终雨水量
        int result = 0;
        //stack.peek是当前位置的高度，stack是一个单调栈（栈底元素小于栈顶元素）
        Stack<Integer> stack = new Stack<>();
        //遍历
        for (int i = 0; i < height.length; i++) {
            //last记录当前层的下一层的高度（比当前层低）
            int last = 0;
            // 循环，计算雨水量
            while (!stack.isEmpty() && height[stack.peek()] <= height[i]) {
                //t表示当前位置
                int t = stack.pop();
                //计算当前层的雨水量
                result += (i - t - 1) * (height[t] - last);
                //更新高度
                last = height[t];
            }
            //如果有不规则层，需要单独计算（只需要计算一次）
            if (!stack.isEmpty()) {
                result += (i - stack.peek() - 1) * (height[i] - last);
            }
            //将当前位置放入栈中
            stack.push(i);
        }
        //返回最终计算结果
        return result;
    }
}
```

### Leetcode 84 Largest Rectangle in Histogram

```java
class Solution {
    public int largestRectangleArea(int[] heights) {

        int length = heights.length;
        int[] left = new int[length];
        int[] right = new int[length];
        Stack<Integer> stack = new Stack<>();

        for (int i = 0; i < length; i++) {
            while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) stack.pop();
            if (stack.isEmpty()) {
                left[i] = -1;
            } else {
                left[i] = stack.peek();
            }
            stack.push(i);
        }

        while (!stack.isEmpty()) stack.pop();

        for (int i = length - 1; i >= 0; i--) {
            while (!stack.isEmpty() && heights[stack.peek()] >= heights[i]) stack.pop();
            if (stack.isEmpty()) {
                right[i] = length;
            } else {
                right[i] = stack.peek();
            }
            stack.push(i);
        }

        int result = 0;
        for (int i = 0; i < length; i++) {
            result = Math.max(result, heights[i] * (right[i] - left[i] - 1));
        }

        return result;
    }
}
```



```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int res = 0;
        Deque<Integer> stack = new ArrayDeque<>();
        int[] new_heights = new int[heights.length + 2];
        for (int i = 1; i < heights.length + 1; i++) new_heights[i] = heights[i - 1];
        //System.out.println(Arrays.toString(new_heights));
        for (int i = 0; i < new_heights.length; i++) {
            //System.out.println(stack.toString());
            while (!stack.isEmpty() && new_heights[stack.peek()] > new_heights[i]) {
                int cur = stack.pop();
                res = Math.max(res, (i - stack.peek() - 1) * new_heights[cur]);
            }
            stack.push(i);
        }
        return res;
    }
}
```



```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        int result = 0;
        int length = heights.length;
        int left;
        int right;
        for (int i = 0; i < length; i++) {
            left = i;
            right = i;

            while (left >= 0 && heights[left] >= heights[i]) {
                left--;
            }

            while (right < length && heights[right] >= heights[i]) {
                right++;
            }
            result = Math.max(result, heights[i] * (right - left - 1));
        }
        return result;
    }
}
```



```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        int maxarea = 0;
        for (int i = 0; i < heights.length; ++i) {
            while (stack.peek() != -1 && heights[stack.peek()] >= heights[i])
                maxarea = Math.max(maxarea, heights[stack.pop()] * (i - stack.peek() - 1));
            stack.push(i);
        }
        while (stack.peek() != -1)
            maxarea = Math.max(maxarea, heights[stack.pop()] * (heights.length - stack.peek() - 1));
        return maxarea;
    }
}
```



### Leetcode 239 Sliding Window Maximum  

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        if (nums.length == 0) {
            return new int[0];
        }
        int[] res = new int[nums.length - k + 1];
        int index = 0;
        Deque<Integer> deque = new ArrayDeque<>();
        for (int i = 0; i < nums.length; i++) {
            // i - k + 1 > deque.peek() 说明对头元素已经出滑动窗口了
            if (!deque.isEmpty() && i - k + 1 > deque.peek()) {
                // 删除对头元素
                deque.pollFirst();
            }

            //如果队尾元素小于当前元素，需要删除队尾元素
            while (!deque.isEmpty() && nums[deque.getLast()] <= nums[i]) {
                deque.pollLast();
            }
            //将当前元素入队
            deque.add(i);
            //如果窗口长度已经大于k，输出滑动串口的最大值
            if (i >= k - 1) {
                // result.add(nums[deque.getFirst()]);
                res[index++] = nums[deque.getFirst()];
            }
        }
        return res;
    }
}
```

### Leetcode 918 Maximum Sum Circular Subarray 

```java
lass Solution {
    public int maxSubarraySumCircular(int[] A) {
        int size = A.length;
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < size; i++) {
            list.add(A[i]);
        }

        for (int i = 0; i < size; i++) {
            list.add(list.get(i));
        }

        List<Integer> sum = new ArrayList<>();
        sum.add(0, 0);
        for (int i = 1; i <= size * 2; i++) {
            sum.add(i, sum.get(i - 1) + list.get(i - 1));
        }

        int res = Integer.MIN_VALUE;
        Deque<Integer> deque = new ArrayDeque<>();
        deque.add(0);
        for (int i = 1; i < size * 2; i++) {
            if (!deque.isEmpty() && i - size > deque.getFirst()) deque.removeFirst();
            if (!deque.isEmpty()) res = Math.max(res, sum.get(i) - sum.get(deque.getFirst()));
            while (!deque.isEmpty() && sum.get(deque.getLast()) >= sum.get(i)) deque.removeLast();
            deque.add(i);
        }
        return res;
    }
}
```