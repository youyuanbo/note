# 树

## 二叉树的创建

## 二叉树前序遍历（递归）

```java
/**
 * 思路：
 *  1. 从根节点开始遍历
 *  2. 如果当前节点不为空，把当前节点添加到集合中
 *  3. 如果当前节点的左子树不为空，递归遍历左子树
 *  4. 如果当前节点的右子树不为空，递归遍历右子树
 *  5. 递归结束，返回谦虚遍历结果
 */
class Solution {

    //定义返回结果集合
    List<Integer> result = new ArrayList<>();

    public List<Integer> preorderTraversal(TreeNode root) {
        //递归遍历二叉树
        dfs(root);
        return result;
    }

    private void dfs(TreeNode root) {
        //如果当前节点为空，返回
        if (root == null) return;
        //将根节点的数据添加到集合中
        result.add(root.val);
        //递归遍历左子树
        dfs(root.left);
        //递归遍历右子树
        dfs(root.right);
    }
}
```



## 二叉树前序遍历（非递归）

```java
/**
 * 二叉树前序遍历（非递归）
 * 思路：
 * 借助栈来完成二叉树的非递归前序遍历
 * 1. 如果root为空，返回一个空集合
 * 2. 初始化栈，向栈中添加root节点
 * 3. 循环，当栈为空时，结束循环
 *  3.1 弹出栈顶元素，并把栈顶元素中的数据添加到结果集合中
 *  3.2 如果当前元素的右孩子不为空，把右孩子添加到栈中
 *  3.3 如果当前元素的左孩子不为空，把左孩子添加到栈中
 * 4. 循环结束，返回结果集合
 */

class Solution {

    public List<Integer> preorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();
        //如果root为空，返回一个空的集合
        if (root == null) return result;
        //初始化栈，将root节点压入栈中
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        //循环，当栈为空时，循环结束
        while (!stack.isEmpty()) {
            //弹出栈顶元素
            TreeNode treeNode = stack.pop();
            //将栈顶元素的数据域添加到result中
            result.add(treeNode.val);
            //如果栈顶元素的right节点不为空，将right节点入栈
            if (treeNode.right != null) {
                stack.push(treeNode.right);
            }
            //如果栈顶元素的left节点不为空，将left节点入栈
            if (treeNode.left != null) {
                stack.push(treeNode.left);
            }
        }
        //返回结果
        return result;
    }
}
```



## 二叉树中序遍历（递归）

```java
/**
 * 使用递归完成二叉树的中序遍历
 * 思路：
 *  1. 先递归遍历二叉树的左子树
 *  2. 将当前节点的数据域添加到集合中
 *  3. 再递归遍历二叉树的右子树
 */

class Solution {
    //定义结果集合
    List<Integer> result = new ArrayList<>();

    public List<Integer> inorderTraversal(TreeNode root) {
        //递归遍历二叉树
        dfs(root);
        //返回结果
        return result;
    }

    private void dfs(TreeNode root) {
        //如果当前节点为空，结束
        if (root == null) return;
        //递归遍历左子树
        dfs(root.left); 
        //将当前节点的数据域添加到result中
        result.add(root.val);
        //递归遍历右子树
        dfs(root.right);
    }
}
```

## 二叉树中序遍历（非递归）

```java
/**
 * 二叉树的中序非递归遍历
 * 
 * 思路:
 *  1. 借助栈完成二叉树的非递归遍历
 *  2. 如果根节点为空，返回一个空的集合
 *  3. 循环（当栈为空并且当前节点也为空时，结束循环）
 *   3.1 将二叉树的最左边的所有节点加入栈中
 *   3.2 弹出栈顶元素，并将其数据域添加到result中
 *   3.3 遍历当前节点的右子树
 *  4. 循环结束，返回result   
 * 
 */

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();

        if (root == null) return result;

        Stack<TreeNode> stack = new Stack<>();

        while (root != null || !stack.isEmpty()) {
            //将二叉树最左边的节点全部添加到栈中
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            //弹出栈顶元素
            root = stack.pop();
            //将root的数据域添加到result中
            result.add(root.val);
            //遍历root的右子树
            root = root.right;
        }
        return result;
    }
}
```

## 二叉树后序遍历（递归）

```java
class Solution {
    List<Integer> result = new ArrayList<>();

    public List<Integer> postorderTraversal(TreeNode root) {
        dfs(root);
        return result;
    }

    private void dfs(TreeNode root) {
        if (root == null) return;

        dfs(root.left);
        dfs(root.right);
        result.add(root.val);
    }
}
```

## 二叉树后序遍历（非递归）

```java
/**
 * 二叉树后序遍历（非递归）
 * 借助栈完成二叉树后序非递归遍历
 * 1. 使用链表作为结果返回
 * 2. 初始化栈，将root入栈
 * 3. 循环（循环结束条件：栈为空）
 *  3.1 将栈顶元素出栈
 *  3.2 将栈顶元素的数据域插入到链表的头结点之前
 *  3.3 如果root.left不为空，将root.left入栈
 *  3.4 如果root.right不为空，将root.right入栈
 * 4. 循环结束，返回结果
 */
class Solution {
    public List<Integer> postorderTraversal(TreeNode root) {
        //定义一个链表
        LinkedList<Integer> result = new LinkedList<>();
        if (root == null) return result;
        //定义一个栈，初始化将root压入栈中
        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);
        while (!stack.isEmpty()) {
            //将栈顶元素出站
            root = stack.pop();
            //将root的数据域插入到链表的头结点之前
            result.addFirst(root.val);
            //如果root.left不为空，将其入栈
            if (root.left != null){
                stack.push(root.left);
            }
            //如果root.right不为空，将其入栈
            if (root.right != null){
                stack.push(root.right);
            }
        }
        return result;
    }
}
```

## 二叉树层序遍历

```java
/**
 * 二叉树的中序非递归遍历
 *
 * 思路:
 *  1. 借助栈完成二叉树的非递归遍历
 *  2. 如果根节点为空，返回一个空的集合
 *  3. 循环（当栈为空并且当前节点也为空时，结束循环）
 *   3.1 将二叉树的最左边的所有节点加入栈中
 *   3.2 弹出栈顶元素，并将其数据域添加到result中
 *   3.3 遍历当前节点的右子树
 *  4. 循环结束，返回result
 *
 */

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> result = new ArrayList<>();

        if (root == null) return result;

        Stack<TreeNode> stack = new Stack<>();

        while (root != null || !stack.isEmpty()) {
            //将二叉树最左边的节点全部添加到栈中
            while (root != null) {
                stack.push(root);
                root = root.left;
            }
            //弹出栈顶元素
            root = stack.pop();
            //将root的数据域添加到result中
            result.add(root.val);
            //遍历root的右子树
            root = root.right;
        }
        return result;
    }
}
```

## 验证二叉搜索树

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if (root == null) return true;
        return dfs(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }

    private boolean dfs(TreeNode root, long min, long max) {
        if (root == null) return true;
        //如果root.val超出了区间范围，返回false
        if (root.val <= min || root.val >= max) return false;
        //递归左子树，最大值变为root.val
        //递归右子树，最小值变为root.val
        return dfs(root.left, min, root.val) && dfs(root.right, root.val, max);
    }
}
```

## 对称二叉树

```java
/**
 * 对称二叉树，利用递归完成
 */
class Solution {
    public boolean isSymmetric(TreeNode root) {
        //如果根节点为空，返回true
        if (root == null) return true;
        //递归，遍历二叉树的左子树与右子树
        return dfs(root.left, root.right);
    }

    private boolean dfs(TreeNode leftNode, TreeNode rightNode) {
        //如果leftNode与rightNode中有一个为空，说明不对称，返回false
        if (leftNode == null || rightNode == null) {
            //如果leftNode与rightNode中，两个都为空，对称，返回true
            return (leftNode == null) && (rightNode == null);
        }

        //如果leftNode.val与rightNode.val不想等，返回false
        //如果相等，继续向下递归，判断leftNode的left与rightNode的right是否相等
        //判断leftNode的right与rightNode的left是否相等
        return (leftNode.val == rightNode.val) &&
                dfs(leftNode.left, rightNode.right) &&
                dfs(leftNode.right, rightNode.left);
    }
}
```

```java
/**
 * 对称二叉树，利用一个队列完成对称二叉树检测
 */

class Solution {
    public boolean isSymmetric(TreeNode root) {
        //如果根节点为空，返回true
        if (root == null) return true;

        //初始化队列，将root入队两次
        Queue<TreeNode> queue = new LinkedList<>();
        queue.add(root);
        queue.add(root);
        //循环 （结束条件：队列为空）
        while (!queue.isEmpty()) {
            //出队两个元素
            TreeNode leftNode = queue.poll();
            TreeNode rightNode = queue.poll();
            //如果两个元素都为空，跳过下面的逻辑，进入下一轮循环
            if (leftNode == null && rightNode == null) continue;
            //如果两个节点中，有一个为空，返回false
            if (leftNode == null || rightNode == null) return false;
            //如果两个节点的数据不想等，返回false
            if (leftNode.val != rightNode.val) return false;
            //左子树左孩子入队
            queue.add(leftNode.left);
            //右子树右孩子入队
            queue.add(rightNode.right);
            //左子树右孩子入队
            queue.add(leftNode.right);
            //右子树左孩子入队
            queue.add(rightNode.left);
        }
        // 返回
        return true;
    }
}
```

## 计算二叉树的高度（深度）

```java
class Solution {
    public int maxDepth(TreeNode root) {
        return (root == null) ? 0 : (Math.max(maxDepth(root.left), maxDepth(root.right)) + 1);
    }
}
```

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if (root == null) return 0;
        Stack<TreeNode> nodeStack = new Stack<>();
        // Stack<Integer> depth = new Satck<>();
        Stack<Integer> depth = new Stack<>();
        nodeStack.push(root);
        depth.push(1);
        int result = 0;
        while (!nodeStack.isEmpty()){
            root = nodeStack.pop();
            int temp = depth.pop();
            result = Math.max(temp, result);
            if (root.left != null) {
                nodeStack.push(root.left);
                depth.push(temp + 1);
            }
            
            if (root.right != null) {
                nodeStack.push(root.right);
                depth.push(temp + 1);
            }
        }
        return result;
    }
}
```

## 根据前序与中序遍历构建二叉树

```java
class Solution {

	Map<Integer, Integer> map = new HashMap<>();

	public TreeNode buildTree(int[] preorder, int[] inorder) {
		int n = preorder.length;

		for (int i = 0; i < n; i++) {
			map.put(inorder[i], i);
		}

		return dfs(preorder, inorder, 0, n - 1, 0, n - 1);

	}

	private TreeNode dfs(int[] preOrder, int[] inOrder, int pl, int pr, int il, int ir) {
		if (pl > pr) return null;

		int val = preOrder[pl];

		int k = map.get(val);

		int len = k - il;

		TreeNode root = new TreeNode(val);

		root.left = dfs(preOrder, inOrder, pl + 1, pl + len, il, k - 1);
		root.right = dfs(preOrder, inOrder, pl + len + 1, pr, k + 1, ir);

		return root;
	}
}
```

## 二叉搜索树中第K小的元素

```java
class Solution {
    int result = 0;
    int index;

    public int kthSmallest(TreeNode root, int k) {
        if (root == null || k == 0) return 0;
        index = k;
        dfs(root);
        return result;
    }

    public void dfs(TreeNode root) {
        if (root == null) return;
        dfs(root.left);
        if (--index == 0) {
            result = root.val;
        }else {
            dfs(root.right);
        }
    }
}
```

## 二叉树的最近公共祖先

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if (root == null || root == p || root == q) return root;

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);

        if(left != null && right != null) return root;

        return left != null ? left : right;
    }
}
```

## 二叉搜索树中第K小的元素

```java
/**
思路：
    1. 利用两个变量来记录二叉树中的最小值与第二小的值
    2. 利用一个计算器count来控制最后的输出
        2.1 如果count为 0，说明没有找到第二小的值，返回-1；
        2.2 如果count不为 1，说明找到了第二小的值，输出即可；
    3. 递归
        3.1 如果当前节点为空，结束当前层的递归
        3.2 如果当前节点的值小于原最小值，则更新最小值与第二小的值
        3.3 如果当前节点的值在原最小值与第二小值之间，则更新第二小的值，并且count++
    4. 递归结束，根据count的值，返回结果
*/
class Solution {
    int first = Integer.MAX_VALUE;
    int second = Integer.MAX_VALUE;
    int count = 0;
    public int findSecondMinimumValue(TreeNode root) {
        dfs(root);
        return count == 0 ? -1 : second;
    }
    
    private void dfs(TreeNode root){
        if (root == null) return;
        
        if(root.val < first) {
            second = first;
            first = root.val;
        } else if (root.val <= second && root.val > first) {
            second = root.val;
            count++;
        }
        
        dfs(root.left);
        dfs(root.right);
    }
}
```

## 根据前序遍历与中序遍历构建二叉树

```java
/**
根据二叉树的前序遍历与中序遍历构建二叉树
    需要借助Map来存储中序遍历中的元素与其在中序遍历中的位置
    1. 将中序遍历中的所有元素以及对应的下标存入map中
    2. 递归创建二叉树
        2.1 递归边界（pl > pr），pl：前序遍历起点，pr：前序遍历终点，il：前序遍历起点，pl：前序遍历终点
        2.2 在前序遍历中取出根节点
        2.3 查询根节点在中序遍历中的位置
        2.4 计算左子树的长度
        2.5 创建节点
        2.6 递归创建左子树
        2.7 递归创建右子树
    3. 递归结束，返回根节点
*/

class Solution {
    // 定义一个map，用来存储中序遍历中的元素与下标
    Map<Integer, Integer> inorderMap = new HashMap<>();
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        // 前序遍历长度
        int preLen = preorder.length;
        // 中序遍历长度
        int inLen = inorder.length;
        // 如果前序遍历长度为0,或者中序遍历长度为0,或者谦虚遍历长度与中序遍历长度不相等,返回null
        if (preLen == 0 || inLen == 0 || preLen != inLen) return null;
        // len代表序列长度
        int len = preLen;
        // 循环,将中序遍历存入map中,便于根据前序遍历中的节点值,查找中序遍历中对应的位置
        for (int i = 0; i < len; i++) {
            inorderMap.put(inorder[i], i);
        }
        // 递归,创建二叉树
        return dfs(preorder, inorder, 0, len - 1, 0, len - 1);
    }
    // pl:前序遍历起点，pr：前序遍历终点，il：中序遍历起点，ir：中序遍历终点
    private TreeNode dfs(int[] preorder, int[] inorder, int pl, int pr, int il, int ir) {
        // 如果前序遍历起点大于了终点，说明在此区间内已经没有元素了，返回
        if (pl > pr) return null;
        // 在前序遍历中取出节点值(根)
        int nodeVal = preorder[pl];
        // 在map中取出当前节点对应的中序遍历中的位置
        int index = inorderMap.get(nodeVal);
        // 计算左子树的长度
        int len = index - il;
        // 创建节点
        TreeNode node = new TreeNode(nodeVal);
        // 递归创建左子树
        // 前序遍历起点, pl + 1, 需要跳过已经创建的节点,
        // 前序遍历终点,pl + len, 终点是左子树结束的位置
        // 中序遍历起点,il,
        // 中序遍历终点, 位于根节点的前一个位
        node.left = dfs(preorder, inorder, pl+1, pl+len, il, index - 1);
        // 递归创建右子树
        // 前序遍历起点, pl + 1 + len, 需要跳过左子树,
        // 前序遍历终点,pr
        // 中序遍历起点,index+1,根节点的后一个
        // 中序遍历终点, ir
        node.right = dfs(preorder, inorder, pl+len+1, pr, index+1, ir);
        // 返回根节点
        return node;
    }
}
```



## 根据中序遍历与后续遍历构建二叉树



## 将二叉树转变为链表

```java
/**
思路：
    1. 在左子树中查找最右的节点，如果左子树为空，则在右子节点中查找
    2. 将右子树挂载左子树的最右节点上
    3. 用左子树替代右子树
    4. 将左子树置空
    5. 当前节点等于当前节点的右子节点
*/

class Solution {
    public void flatten(TreeNode root) {
        while (root != null) {
            // 如果root.left == null，则root = root.right
            if(root.left == null) {
                root = root.right;
            } else {
                // pre代表前一个节点，是左子结点的最右端节点
                TreeNode pre = root.left;
                while (pre.right != null) {
                    pre = pre.right;
                }
                // 将右子节点挂载到pre的右子节点上
                pre.right = root.right;
                // 将左子树把右子树替换掉
                root.right = root.left;
                // 将左子结点置为空
                root.left = null;
                // 向下继续遍历
                root = root.right;
            }
        }
    }
}
```

## 根据前序遍历构建二叉搜索树

```java
class Solution {
    Map<Integer, Integer> map = new HashMap<>();

    public TreeNode bstFromPreorder(int[] preorder) {

        if (preorder.length == 0) return null;

        int[] inOrder = Arrays.copyOf(preorder, preorder.length);
        Arrays.sort(inOrder);

        int len = inOrder.length;
        for (int i = 0; i < len; i++) {
            map.put(inOrder[i], i);
        }

        return dfs(preorder, inOrder, 0, len - 1, 0, len - 1);

    }

    public TreeNode dfs(int[] preOrder, int[] inOrder, int pl, int pr, int il, int ir) {
        if (pl > pr) return null;

        int nodeVal = preOrder[pl];
        int index = map.get(nodeVal);
        int len = index - il;
        TreeNode treeNode = new TreeNode(nodeVal);
        treeNode.left = dfs(preOrder, inOrder, pl + 1, pl + len, il, index - 1);
        treeNode.right = dfs(preOrder, inOrder, pl + 1 + len, pr, index + 1, ir);
        return treeNode;
    }
}
```

