#  链表







##两数相加

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        // 如果l1与l2同时为空，返回null
        if (l1 == null && l2 == null) return null;
        // 如果l1与l2中有一个为空，返回非空的那一个
        if (l1 == null || l2 == null) return l1 == null ? l2 : l1;
        // 建立虚拟头结点
        ListNode dummy = new ListNode(-10);
        // 建立工作指针
        ListNode cur = dummy;
        // 进位
        int carry = 0;
        // 只要l1与l2不同时为空，即可循环
        while (l1 != null || l2 != null) {
            // 取出当前节点的值
            int val1 = (l1 != null) ? l1.val : 0;
            int val2 = (l2 != null) ? l2.val : 0;
            // 计算当前两个节点的和
            int sum = val1 + val2 + carry;
            // 创建新的节点，挂载工作节点之后
            cur.next = new ListNode(sum % 10);
            // 将工作指针向后移动
            cur = cur.next;
            // 计算进位
            carry = sum / 10;
            // 如果当前指针不为空，将当前指针向后移动
            // 如果当前指针为空，则不移动当前指针
            l1 = (l1 != null) ? l1.next : null;
            l2 = (l2 != null) ? l2.next : null;

        }
        // 循环完毕，如果进位大于 0，需要再添加一个节点
        if (carry > 0) {
            cur.next = new ListNode(carry);
        }
        // 返回头结点
        return dummy.next;
    }
}
```



## 合并两个有序链表

```java
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        // 如果l1与l2都为空，返回null
        if (l1 == null && l2 == null) return null;
        // 如果l1与l2不同时为空，返回非空的节点
        if (l1 == null || l2 == null) return (l1 == null) ? l2 : l1;
        // 新建虚拟头结点
        ListNode dummy = new ListNode(-1);
        // 新建工作指针
        ListNode cur = dummy;
        // 循环，（结束条件：l1为空或l2为空）
        while (l1 != null && l2 != null) {
            // 如果l1的值小于或等于l2的值，将l1挂载到cur后面，l1向后移动
            if (l1.val <= l2.val) {
                cur.next = l1;
                l1 = l1.next;
            } else {
                // 如果l1的值大于l2的值，将l2挂载到cur后面，l2向后移动
                cur.next = l2;
                l2 = l2.next;
            }
            // 将工作指针向后移动
            cur = cur.next;
        }
        // 如果循环结束后，l1不为空，将l1挂载到cur后面
        if (l1 != null) {
            cur.next = l1;
        }
        // 如果循环结束后，l2不为空，将l2挂载到cur后面
        if (l2 != null) {
            cur.next = l2;
        }
        // 返回头结点
        return dummy.next;
    }
}
```



## 旋转链表

```java
class Solution {
    public ListNode rotateRight(ListNode head, int k) {
        // 如果head为空或k小于0 返回null
        if (head == null || k < 0) return null;

        int len = 0;
        ListNode first = head;
        ListNode second = head;
        // 计算链表长度
        while (first != null) {
            len++;
            first = first.next;
        }
        //如果k == 0 或者k == len 返回head
        if (k == 0 || k == len) return head;

        // 防止k 大于链表长度
        k %= len;
        first = head;
        // 让first先走k步
        for (int i = 0; i < k; i++) {
            first = first.next;
        }
        
        // 让first与second同步向后移动，直到first指向链表的最后一个元素
        while (first.next != null) {
            first = first.next;
            second = second.next;
        }
        
        // 将最后一个元素的next指向head
        first.next = head;
        //让head指向second.next
        head = second.next;
        // 让second.next指向null
        second.next = null;
        // 返回head
        return head;
    }
}
```



## 判断链表中是否存在环

```java
/**
 * 利用双指针判断链表中是否存在环
 * 1. 如果head为空或者head.next为空，返回false
 * 2. 定义slow指针，初始化指向head，每一次走一步
 * 3. 定义fast指针，初始化指向head.next，每一次走两步
 * 4. 循环（结束条件：slow指针与fast指针指向了同一个节点）
 *  4.1 如果fast指针所指向的节点为空，或者fast.next指针为空，返回false
 *  4.2 将slow指针向后移动一步，fast指针向后移动两步
 * 5. 循环结速，返回true
 */

class Solution {
    public boolean hasCycle(ListNode head) {
        //判断边界条件
        if (head == null || head.next == null) return false;
        //定义快慢指针
        ListNode slow = head;
        ListNode fast = head.next;
        //遍历链表
        while (slow != fast) {
            //如果存在指针指向null，返回false
            if (fast == null || fast.next == null) return false;
            // 将指针向后移动
            slow = slow.next;
            fast = fast.next.next;
        }
        //循环结束，返回true
        return true;
    }
}
```

