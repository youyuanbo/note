# 设计模式

## 面向对象设计的基本原则

### 开闭原则（OCP）

​	一个软件的实体，应当对扩展开放，对修改关闭。

### 依赖倒转原则（DIP）

​	要针对接口编程，不要针对实现编程。	

### 迪米特法则（LoD）

​	只与你直接的朋友通信，而避免和陌生人通信。

## 创建型模式

### 单例模式

​	**定义**：保证一个类只有一个实例，并且提供一个访问该实例的全局访问点。

![1561208187078](E:\Note\java\设计模式\img\1561208187078.png)

**优点**

![1561209103046](E:\Note\java\设计模式\img\1561209103046.png)

**常见的五种实现方式**

![1561209124578](E:\Note\java\设计模式\img\1561209124578.png)

1. 饿汉式

   ```java
   public class Hungry {
      private static Hungry hungry = new Hungry();
      private Hungry() {
      }
      public static Hungry getInstance() {
         return hungry;
      }
   }
   ```

   

   ```java
   @Test
   public void testHungry(){
      Hungry hungry = Hungry.getInstance();
      Hungry hungry1 = Hungry.getInstance();
      System.out.println(hungry == hungry1);
   }
   ```

2. 懒汉式

   ```java
   public class LazyDemo {
   
      private static LazyDemo lazyDemo = null;
   
      private LazyDemo(){
   
      }
   
      public static synchronized LazyDemo getInstance(){
         if (lazyDemo == null){
            return new LazyDemo();
         }
         return lazyDemo;
      }
   }
   ```

   测试

   ```java
   @Test
   public void testLazyLoad(){
      LazyDemo lazyDemo = LazyDemo.getInstance();
      LazyDemo lazyDemo1 = LazyDemo.getInstance();
   
      System.out.println(lazyDemo);
      System.out.println(lazyDemo1);
   
      System.out.println(lazyDemo == lazyDemo1);
   
   }
   ```

3. 双重检测锁

4. 静态内部类

   ```java
   public class StaticInnerClass {
   
      private StaticInnerClass(){
   
      }
   
      private static class SingletonClassInstance{
         private static final StaticInnerClass instance = new StaticInnerClass();
      }
   
      private static StaticInnerClass getInstance(){
         return SingletonClassInstance.instance;
      }
   
   }
   ```

5. 枚举

   ```java
   public enum  EnumInstance {
   
      INSTANCE;
   
      //直接通过类名即可获取
   }
   ```

   这个枚举对象，本身就是单例。但是不能延迟加载。可以防止反射与反序列化的漏洞。

6. 通过反射破坏单例

   ```java
   public class SingletonReflect {
      private static SingletonReflect ourInstance = new SingletonReflect();
   
      public static SingletonReflect getInstance() {
         return ourInstance;
      }
   
      private SingletonReflect() {
      }
   }
   ```

   测试

   ```java
   public static void main(String[] args) throws Exception {
   
      SingletonReflect instance1 = SingletonReflect.getInstance();
      SingletonReflect instance2 = SingletonReflect.getInstance();
      System.out.println(instance1);
      System.out.println(instance2);
   
      Class<SingletonReflect> aClass = (Class<SingletonReflect>) Class.forName("com.xiaoyou.singleton.SingletonReflect");
      Constructor<SingletonReflect> constructor = aClass.getDeclaredConstructor(null);
      constructor.setAccessible(true);
   
      SingletonReflect singletonReflect1 = constructor.newInstance();
      SingletonReflect singletonReflect2 = constructor.newInstance();
      System.out.println(singletonReflect1);
      System.out.println(singletonReflect2);
       //singletonReflect1与singletonReflect2结果不一样
   
   }
   ```

   解决方法：

   在构造方法中加入如下代码：

   ```java
   if(ourInstance != null){
      throw new RuntimeException("多次创建异常");
   }
   ```

   

7. 通过反序列化破坏单例

8. 

### 工厂模式

实现了创建者与调用者的分离。

**实质：**

1. 实例化对象，用工厂方法代替new操作。
2. 将选择实现类，创建对象统一管理与控制。从而将调用者与实现类解耦。

#### 简单工厂模式



#### 抽象工厂模式

#### 抽象工厂

### 建造者模式

### 原型模式



## 结构型模式

### 适配器模式

### 桥接模式

### 装饰模式

### 组合模式

### 外观模式

### 亨元模式

### 代理模式

## 行为型模式

### 模板方法模式

### 命令模式

### 迭代器模式

### 观察者模式

### 中介者模式

### 备忘录模式

### 状态模式

### 策略模式

### 职责链模式

### 访问者模式